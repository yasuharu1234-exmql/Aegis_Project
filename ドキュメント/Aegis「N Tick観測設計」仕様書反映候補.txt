[Claude]

**セルフチェック：**
- AI名：Claude
- 役割：実装担当

---

## 📝 Aegis「N Tick観測設計」仕様書反映候補

**作成日:** 2026年1月8日  
**作成者:** Claude（実装担当）  
**文書種別:** 設計整理メモ（仕様書反映候補）  
**目的:** 観測周期設計の正当性と効果の文書化

---

## 1. 観測層（Observation）の責務再定義

### 1-1. なぜ毎Tick入力を受け取るのか

**原則:**
市場の事実は毎Tick発生する。観測層は「見逃さない」ことが第一の責務。

**理由:**
- 市場の価格変動は連続的に発生する
- どのTickが重要かは事前に判断できない
- 観測層は「判断の材料」を提供する役割であり、判断自体は行わない

**設計上の位置づけ:**
観測層は「センサー」である。センサーは常時稼働し、データを蓄積する。

---

### 1-2. N Tickを1ウィンドウとする意味

**背景:**
毎Tickの微小な価格変動をそのまま判断層に渡すと、以下の問題が発生する：
- 市場ノイズを増幅する
- 計算負荷が無駄に高い
- 人間が「フラフラしている」と認識する

**解決策:**
N Tickを1単位として、その期間内の価格情報を「要約」する。

**要約の意味:**
- 高値：期間内で最も高い価格
- 安値：期間内で最も低い価格
- 始値：期間開始時の価格
- 終値：期間終了時の価格

これらは「N Tick期間の市場特性」を代表する指標となる。

**N の決定方針:**
- 小さすぎる → ノイズを吸収できない
- 大きすぎる → 市場変化への追従が遅れる
- N = 50 は初期値（バックテストで調整可能）
- **重要:** N は設定値であり、ハードコード禁止

---

### 1-3. ウィンドウ内で保持すべき情報

#### 必須項目
- **高値（WindowHigh）**: ウィンドウ内の最高価格
- **安値（WindowLow）**: ウィンドウ内の最低価格

この2つだけで以下が可能：
- 追従型戦略（高値・安値を基準に注文配置）
- ブレイクアウト戦略（高値・安値の突破判定）
- レンジ判定（高値・安値の差でレンジ幅計算）

#### 拡張候補
- **始値（WindowOpen）**: ウィンドウ開始時の価格
- **終値（WindowClose）**: ウィンドウ終了時の価格
- **中心価格（WindowMid）**: (高値 + 安値) / 2
- **レンジ幅（WindowRange）**: 高値 - 安値

**拡張の意義:**
- より高度な戦略に対応可能
- 市場の方向性やボラティリティを判断材料に追加
- 判断層が「どの値を使うか」を選択できる柔軟性

#### デバッグ用情報
- **ウィンドウID**: 何番目のウィンドウか
- **Tick数**: 現在ウィンドウ内で何Tick目か

**保持しないもの:**
- 全Tickの価格履歴（メモリ効率）
- 判断に必要ない詳細情報

---

### 1-4. 「今が判断可能タイミングか」を通知する仕組み

**概念:**
観測層は「観測結果が確定したタイミング」を判断層に通知する必要がある。

**通知方法:**
フラグ型の状態変数（例: Obs_Updated）を使用。

**動作:**
- N Tick目（ウィンドウ終了時）: Obs_Updated = true
- それ以外のTick: Obs_Updated = false

**意義:**
- 判断層は「今、判断すべきか」を自律的に判断できる
- 観測層は「判断しろ」とは言わない（責務分離）
- 観測層は「判断材料が揃った」とだけ通知する

**設計上の重要性:**
これにより、判断層は「待つ」ことができる。
「待つ」は「サボり」ではなく、「安定した判断材料を得るための設計」である。

---

## 2. 判断層（Decision）の振る舞い整理

### 2-1. 観測結果 → 状態（State）への変換

**判断層の本質的役割:**
「観測された事実」を「どう行動すべきか」に変換すること。

**変換の例:**
```
観測: ウィンドウ高値 = 150.50
     ウィンドウ安値 = 150.00
     
判断: 現在の注文を高値+50pt、安値-50ptに配置すべき
     
結果: ACTION_OCO_MODIFY を生成
```

**重要な点:**
判断層は「観測層が確定させた値」だけを使う。
生のask/bidを直接参照しない。

---

### 2-2. 毎Tick即応が必要な判断と、N Tick確定後のみ行う判断

#### 毎Tick即応が必要な判断
**例: ポジション検出によるCANCEL**
- 状況: ポジションが約定した
- 必要性: 即座に残った注文をキャンセル
- 理由: ウィンドウ終了を待つと損失拡大の可能性

**観測:**
- CObservationOCOStateは毎Tick動作
- ポジション検出は即座に行う

**判断:**
- has_position == true なら即座にACTION_OCO_CANCEL

#### N Tick確定後のみ行う判断
**例: OCO注文の追従**
- 状況: 市場価格が変動している
- 必要性: 安定した基準で追従したい
- 理由: 毎Tickの微小変動に反応すると不安定

**観測:**
- N Tickごとに高値・安値を確定

**判断:**
- Obs_Updated == true のときだけACTION_OCO_MODIFY

---

### 2-3. Obs_Updated的フラグの役割

**概念:**
「判断材料が新しくなった」という通知。

**判断層の動作:**
```
毎Tick呼ばれる

if (Obs_Updated == false)
    → ACTION_NONE を返す（判断材料が古いまま）

if (Obs_Updated == true)
    → 通常の判断ロジックを実行
    → 適切なActionを生成
```

**設計上の効果:**
- 判断層は「無駄な判断」をしない
- 判断層は「判断タイミング」を観測層から受け取る
- 判断層のロジック本体は変更不要（1行のif文追加のみ）

**重要な洞察:**
判断層が「待つ」のは、観測層が「まだ確定していない」と教えてくれるから。
これは設計の分離が正しく機能している証拠。

---

## 3. 実行層（Execution）が一切変わらない理由

### 3-1. Action頻度が変わっても設計が崩れない理由

**実行層の責務:**
「Actionを受け取ったら実行する」だけ。

**Actionの頻度:**
- N Tick設計前: 毎Tick ACTION_OCO_MODIFY が来る
- N Tick設計後: N Tickに1回 ACTION_OCO_MODIFY が来る

**実行層から見た変化:**
- Actionの「内容」は同じ
- Actionの「頻度」だけが変わった

**なぜ設計が崩れないか:**
実行層は「いつActionが来るか」を知る必要がない。
来たら実行する、来なければ何もしない。これだけ。

**設計の美しさ:**
```
観測層: 観測周期を変更
判断層: 判断タイミングを変更
実行層: 何も変わらない
```

これが「責務分離」の価値。

---

### 3-2. ACTION_NONEが大量に流れても問題ない理由

**N Tick設計後の典型的な流れ:**
```
Tick 1-49: ACTION_NONE × 49回
Tick 50:   ACTION_OCO_MODIFY × 1回
```

**ACTION_NONEの意味:**
「今は何もしない」という正当な判断結果。

**実行層の処理:**
```
if (action.type == ACTION_NONE)
    return true;  // 何もせず成功
```

**コスト:**
- 計算コスト: ほぼゼロ（単純な分岐）
- メモリコスト: ゼロ（何も実行しない）
- 通信コスト: ゼロ（OrderSendしない）

**設計上の意義:**
ACTION_NONEは「無駄」ではなく、「判断の結果」である。
「何もしないことを選んだ」という意思決定の記録。

---

## 4. フラつき問題に対する設計的検証視点

### 4-1. 「もし別原因があるなら、N Tick化しても現象は残る」

**検証の考え方:**
N Tick設計は「頻度」の問題を解決する。

**もし頻度以外に原因があれば:**
- N Tick化してもフラつきは残る
- 例: 計算式のバグ、基準価格の誤り、等

**N Tick化後にフラつきが消えれば:**
- 原因は「頻度」だったと確定
- 計算式は正しかったことの証明

**設計的価値:**
N Tick設計は「解決策」であると同時に「原因特定装置」でもある。

---

### 4-2. N Tick設計が原因切り分け装置として機能する理由

**検証可能な仮説:**
1. 頻度が原因 → N Tick化で解決
2. 計算式が原因 → N Tick化しても残る
3. 基準価格が原因 → N Tick化しても残る

**実験設計として優秀な点:**
- 変更箇所が明確（観測周期のみ）
- 他の要素を変更しない
- 結果が明確（フラつくか、しないか）

**科学的手法:**
これは「制御された実験」である。
1変数だけを変更し、結果を観察する。

---

### 4-3. 設計ミスと市場ノイズを分離できる理由

**問題の切り分け:**

#### ケースA: N Tick化でフラつきが消えた
- 結論: 市場ノイズが原因だった
- 設計: 正しい（計算式は合っていた）
- 解決: 観測周期の最適化で対応

#### ケースB: N Tick化してもフラつきが残る
- 結論: 設計ミスが原因
- 候補: 計算式、基準価格、型精度、等
- 対応: ロジックの再検証

**重要な洞察:**
N Tick設計を実装する前に、「もし消えなかったら何が原因か」を考えておく。
これが設計者の仕事。

---

## 5. 全体設計への効果

### 5-1. なぜ毎Tickで判断しないのか

**答え:**
毎Tickの判断は「市場ノイズを増幅する」から。

**詳細:**
- 市場価格は毎Tick微小に変動する
- その変動の多くは「ノイズ」（意味のない揺らぎ）
- ノイズに反応して毎Tick行動すると、結果もノイズになる

**N Tick設計の効果:**
- N Tick分のノイズを「平滑化」する
- 意味のある価格変動だけを捉える
- 人間が「安定している」と認識できる

---

### 5-2. なぜ観測と判断の周期を分けるのか

**答え:**
観測と判断は「異なる責務」だから。

**観測の責務:**
- 事実を記録する
- 見逃さない
- 判断しない

**判断の責務:**
- 事実を解釈する
- 行動を決める
- 実行しない

**周期を分ける意義:**
- 観測: 毎Tick（高頻度）
- 判断: N Tickごと（低頻度）
- これにより、「見逃さず、騒がない」が実現する

---

### 5-3. N Tickという設計がAegis全体にどう効くのか

**効果①: ノイズ耐性**
- 微小な価格変動を吸収
- 安定した判断材料を提供

**効果②: 計算効率**
- 判断・実行が1/N に削減
- OrderSend回数が激減

**効果③: 説明可能性**
- 「N Tickの高値を基準に追従」と言える
- ログが人間に理解しやすい

**効果④: 保守性**
- 観測周期を変更してもロジックは変わらない
- N は設定値として調整可能

**効果⑤: テスト容易性**
- N = 1 にすれば従来動作（毎Tick判断）
- N を変えて比較実験が可能

---

## 6. 実装への示唆

**観測層への追加:**
- N Tickカウンタ
- ウィンドウ内の高値・安値蓄積
- Obs_Updated フラグ管理

**判断層への追加:**
- 冒頭に Obs_Updated チェック（1行）
- 基準価格の参照先変更

**実行層:**
- 変更なし

**設定パラメータ:**
- WindowSize（N）: デフォルト50、調整可能

---

## 7. 今後の拡張性

**N Tickウィンドウは拡張可能:**
- 複数の時間軸（10Tick、50Tick、200Tick）を同時観測
- 短期・中期・長期のトレンド判定
- マルチタイムフレーム分析

**判断層の拡張:**
- ウィンドウ内の高値・安値だけでなく
- ボラティリティ、方向性、等も判断材料に

**この設計は「スケーラブル」:**
- 1つのウィンドウで動作確認
- 複数ウィンドウへの拡張は容易

---

**以上、2026年1月8日 設計整理完了**

**この文書は将来、Aegis仕様書に反映可能な形式で作成されています。**

---

**Claude（実装担当）**