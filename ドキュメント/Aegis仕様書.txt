========================================
ここからAegis概要説明
========================================
Aegis ハイブリッドEA基盤
Configurable Logic Architecture – Unified Decision Engine
はじめに

トレードシステムの本質は、次の3つに集約される。

観測 ― 市場で何が起きているかを知る
判断 ― 得られた事実をもとに行動を決める
実行 ― 決定を市場に反映する

多くのEAは、これらを一体化したまま設計される。
その結果、

どこで判断が行われたのか分からない

なぜ失敗したのか説明できない

修正しようとすると全体が壊れる

という問題を抱える。

Aegis はこの問題を構造から解決するための基盤である。

設計思想

Aegis は以下の原則を最上位に置く。

1. 分離の徹底
観測は判断しない。
判断は実行しない。
実行は理由を問わない。

各機能は自分の責務だけを果たし、他の内部を知らない。

2. 説明可能性の最優先
Aegis は「勝つEA」ではなく、
「壊れた理由を必ず説明できるEA」を目指す。

負けることよりも、
「なぜ負けたか分からないこと」を最大の失敗と定義する。

3. 拡張前提の設計
戦略・指標・注文方法は後から追加される。
そのため、最初から「壊さず増やせる構造」を前提とする。

4. 環境差異の隠蔽
MT4 / MT5、テスター / 本番といった差異は、
基盤層が吸収し、戦略はそれを意識しない。

システムの構成

Aegis は複数のレイヤーから成る。

観測：市場の事実を取得する

判断：取引するか否かを決める

実行：注文として市場に反映する

記録：すべての判断と失敗を残す

基盤：プラットフォーム差異と安全制御を担う

これらは上下関係を持つが、相互に侵入しない。

Aegis が実現すること

戦略を差し替えても壊れない

ログを見れば、何が起きたか追える

実装が増えても整理されたまま

10年後でも設計意図を思い出せる

実現しないこと

未来の予測

聖杯の提供

人間の判断を完全に排除すること

Aegis は「考える人間」を補助するための道具である。

結び

Aegis は完成品ではない。
進化し続ける前提の基盤である。

戦略は入れ替わる。
市場は変わる。

それでも、
「なぜそう動いたか」が分かる限り、
このシステムは使い続けられる。


========================================
ここからAegis機能一覧
========================================
Aegis 機能一覧（叩き台）
1. 制御・安全系

Tick起点の単一制御

再入防止

即時遮断（異常検知時）

2. 観測系

価格・時間・スプレッド取得

テクニカル指標観測（プラグイン）

経済指標観測（任意・将来）

3. 判断系

環境認識（結果として）

取引可否判断（Yes / No / Block）

外部設定による判断ルール

4. 実行系

OCO注文管理

ポジション状態管理

追従・決済制御（詳細は別仕様）

5. 記録系

構造化ログ

状態遷移記録

破壊点記録

6. 基盤系

MT4 / MT5 差異吸収

時間管理

エラーハンドリング

共通データ定義

========================================
ここから追従型OCO戦略仕様書
========================================
追従型OCO戦略仕様書 v0.2（暫定）

0. 目的
本Strategyは「市場が有効な時間帯にのみ OCO（BuyStop/SellStop）を配置し、
未約定の間は価格を更新（追従）し、片側が約定したら反対側の注文を確実に取消する」ことを目的とする。

※ 約定後の SL/TP 追従（トレイル/BE 等）は本Strategyの責務ではない。
   （別Strategyへ引き継ぐ）

1. 入力（Aegis → 追従型OCO）
- Observation層の事実（価格、スプレッド、時間帯、注文/ポジション状態など）
- Aegisが与える動作権限（Gatekeeper OK 等）
- Aegisが決定したリスク（ロット、SL/TP 等は原則 Aegis側）

2. 出力（追従型OCO → Aegis）
本Strategyの返答は必ず以下のいずれかのみ。
1) 無操作（NOOP）
2) 注文更新（OCO価格更新：PLACE or MODIFY）
3) 役割終了通知（今後このStrategyは新規OCOを出さない）

※「役割終了」は、注文約定やポジションクローズを意味しない。
※ 約定検出時に行うべきことは「反対側注文の取消」であり、これをもって役割完了とする。

3. 初期配置条件
以下をすべて満たす場合のみ初期配置する。
- Aegisが動作権限を渡している（Gatekeeper OK）
- ポジションが存在しない
- OCO注文（対象マジック/シンボル）が存在しない

4. 初期配置内容
- Buy Stop ×1 / Sell Stop ×1
- 注文距離：パラメータ（変数）から決定（#define固定は禁止）
- ロット：Aegis側で決定済み（暫定：Strategy側でも仮値可）
- SL/TP：Aegis側で決定済み（暫定：仮値可）

5. 追従（未約定OCOの価格更新）
5.1 定義
「追従」とは、未約定OCO注文の価格を現在価格（＋将来は状況）を基準に更新すること。
※ 約定後の SL/TP 更新は追従ではない。

5.2 追従条件（暫定）
- 未約定OCOが存在する
- 同一ティック内1回まで
- 既存注文より “有利方向” の場合のみ更新
  （BuyStopは下げる方向、SellStopは上げる方向 ＝ 現在価格へ近づける）

5.3 更新手段
- 原則：TRADE_ACTION_MODIFY（注文価格/SL/TPの変更）を使用
- CANCEL→再配置は行わない（例外は実装後）

6. 約定検出時の責務
- 片側の約定を検出したら、反対側の未約定注文を確実に取消する。
- 両建て（両側約定）などイレギュラー検出時は、残った注文を全取消しし、役割終了通知を返す。
  （ポジション処理は別Strategyへ引き継ぐ）

7. 完了条件（このStrategyのゴール）
- OCOを出せた
- 片側の約定を検出できた
- 反対側注文を取消できた
- 以後は「役割終了通知」を返し続ける（or 無操作）


========================================
ここからAegis 開発規約
========================================
📘 Aegis 開発規約（簡易版 / Phase 2以降）
0. この文書の位置づけ


本規約は Aegis 開発時の安全装置である


設計思想より 事故防止・復旧容易性を最優先する


AI実装者・監査役（Gemini / Genspark）ともに遵守対象



1. 変更ファイル数の制限（最重要）
🔒 原則


1回の作業で変更してよいファイルは最大2ファイルまで


例外なし（コメント追加・軽微修正も含む）


🔍 監視ポイント（Gemini / Genspark向け）


3ファイル以上に言及が出た時点で 警告


「ついでに」「合わせて」等の表現は 危険兆候



2. データ構造変更の厳格な手順
📐 データ構造とは


struct


enum


Context（CLA_Data 等）のメンバ


レイヤー間の受け渡し情報


🧭 手順（厳守）
Step 1
👉 データ側のみ修正
（ロジック・処理コードは一切触らない）
Step 2
👉 単体コンパイル確認


コンパイルエラー 0


ワーニング 0


Step 3
👉 問題なければ、次の作業単位でロジック実装
🔍 監視ポイント


データ変更とロジック変更が同時に出てきたら 即NG


「ついでにロジックも直しました」は 設計違反



3. 絶対禁止事項（即ロールバック対象）
🚫 ファイル・構造系


#include 行の変更（1文字でもNG）


既存メンバ変数の削除・意味変更


enum / struct 名の変更・改名


ディレクトリ構造の変更提案


🚫 設計・思考系


再設計・リファクタリング


最適化・整理・「より良くしました」


仕様の拡張・解釈変更


👉 Aegisでは「良かれと思って」は最大の事故原因

4. AI実装者の役割定義
🧠 ChatGPT（PM / 設計統括）


作業範囲の明確化


修正対象ファイルの指定


手順違反の検知と停止判断


🔍 Gemini / Genspark（監査役）


コンテキスト消費は気にしなくてよい


以下を重点監視：


監視チェックリスト


変更ファイル数 > 2 になっていないか


データとロジックが同時に触られていないか


include / enum / struct 名が変わっていないか


「設計を良くする」系の発言が出ていないか


👉
「ちょっと大きすぎません？」と言うだけでOK
止めるのが仕事。解決策は不要。

5. ロールバックの原則


迷ったら 必ずロールバック


AIの説明より コンパイル結果を信頼


正本（Master）は「最後に成功した状態」



6. 合言葉（重要）

「壊さないために、遅くする」

Aegisは


速く作るEAではない


壊れた理由を説明できるEAである

7. その他

各MQLソースファイルは、本来の拡張子は「.mq4」「.mq5」「.mqh」であるが、
各AI環境の制約により、「.txt」に変換されて格納されている。
ファイルヘッダーに本来の拡張子が書かれているので、そちらを参照する事。

📌 まとめ（1行版）


変更は最大2ファイル


データ → コンパイル → ロジック


include・enum・structは触るな


大きくなったら止める




========================================
ここからAI同士の会話ルール
========================================
【AI同士の会話ルール】

1.最初に名乗る事。

・Geminiの場合、[Gemini]
・Claudeの場合、[Claude]
・ChatGPTの場合、[ChatGPT]
・Gensparkの場合、[Genspark]
・私(ヤスハル)の場合、[ヤスハル]
※ただし、私はAIではないので名乗りを忘れがちです。できるだけ努力はしますが、忘れている時は推測してください。「名乗りを忘れてるよ！」というツッコミも大丈夫です（笑）

2.上記、「名乗り」を含めて、メッセージは全文コピーされて相手のチャットにペーストされます。
相手AIに対するメッセージだけを書き、余計な事は書かない事。

3.私(ヤスハル)が割り込む際は、
[ヤスハル]と名乗ります。
それまでは安易に私に話しかけない事。
※会話はちゃんと見ています。
 
4.このルールはAI同士の会話でのみ有効であり、それが終了した時点で無効になります。

5.発言者は私が指定します。それまでは待機です。

========================================
Claude向け実装指示書
========================================


# 📘 Claude向け実装指示書

## Aegis Logger Phase 1（ILogger + Panic）

---

## 🎯 ゴール（絶対）

* **ログ設計を確定させない**
* **仮enum回収作戦を前提に実装する**
* **Aegis全体を止めずに、今すぐ組み込める Logger を作る**
* **Panicログだけは「本気仕様」**

---

## 0. 実装範囲（厳守）

### ✅ 実装するもの

1. `ILogger` インターフェース
2. `CFileLogger`（仮実装OK）
3. `Panic()` ログ経路（最優先）
4. 仮LOG_ID前提の通常ログ経路

### ❌ 実装しないもの（今は不要）

* CLA_Data の中身の編集
* Snapshot / ダンプの本格実装
* enum LOG_ID の完全定義
* 高性能最適化

---

## 1. 仮enum回収作戦（必須ルール）

### Claudeへの最重要ルール

> **LOG_IDは確定させない。enumを作らない。**

### 仮IDの扱い

* 各ファイル先頭に `#define LOG_ID_xxx` を置く
* enumっぽい名前にする
* 数値は仮でよい
* 後で回収される前提

例：

```mql
// ===== TEMP LOG IDs (TO BE COLLECTED) =====
#define LOG_ID_EXEC_PLACE    3001
#define LOG_ID_EXEC_RESULT   3002
```

---

## 2. ILogger インターフェース（確定）

### ファイル

```
/CLA/04_Execution/ILogger.mqh
```

### 定義（このまま使う）

```mql
class ILogger
{
public:
    // 通常ログ（IDベース・軽量）
    virtual void Log(
        int log_id,
        uchar level,
        int p1 = 0,
        int p2 = 0
    ) = 0;

    // パニックログ（フリーフォーマット・最優先）
    virtual void Panic(
        int panic_id,
        const string &message
    ) = 0;

    // 明示FLUSH要求
    virtual void Flush() = 0;
};
```

---

## 3. Panicログ（最重要）

### Panicログの思想（理解必須）

* **なりふり構わない**
* **文字列OK**
* **Print()併用OK**
* **即Flush**
* **Verbose/Level無視OK**

---

### Panic ID（ここだけ確定）

```mql
enum ENUM_PANIC_LOG_ID
{
    PANIC_UNKNOWN              = 9000,
    PANIC_MEMORY_CORRUPTION    = 9001,
    PANIC_ORDER_STATE_BROKEN   = 9002,
    PANIC_EXECUTION_INCONSIST  = 9003,
    PANIC_LOGGER_FAILURE       = 9004,
    PANIC_INTERNAL_ASSERT      = 9005,
    PANIC_MANUAL_TRIGGER       = 9099
};
```

※ この enum は **CLA_Common.mqh に追加してOK**

---

## 4. CFileLogger（Phase 1仕様）

### ファイル

```
/CLA/04_Execution/CFileLogger.mqh
```

### 内部状態（最低限）

```mql
class CFileLogger : public ILogger
{
private:
    int    m_count;          // ログ件数
    int    m_max_records;    // 最大件数（inputで設定）
    bool   m_enabled;

public:
    bool Init(int max_records);
    void Log(int log_id, uchar level, int p1=0, int p2=0);
    void Panic(int panic_id, const string &message);
    void Flush();
};
```

---

### Phase 1での挙動（割り切り）

#### Log()

* メモリ配列に保存 **または**
* 仮で `Print()` でもOK
* **件数のみカウント**

#### Panic()

* `Print()` に即時出力（必須）
* 内容：

  ```
  [PANIC][9003] Execution inconsistency detected
  ```
* 直後に `Flush()` を必ず呼ぶ

#### Flush()

* 今は `Print("[Logger] Flush called")` でOK
* 後で本実装に差し替える前提

---

## 5. 最大ログ容量（件数ベース）

### 方針

* **容量は件数で管理**
* テキストエディタの「行数」と一致する思想

### Init例

```mql
input int InpMaxLogRecords = 10000;

bool CFileLogger::Init(int max_records)
{
    m_max_records = max_records;
    m_count = 0;
    m_enabled = true;
    return true;
}
```

---

## 6. 呼び出し側の使い方（例）

```mql
logger.Log(LOG_ID_EXEC_PLACE, 2, ticket, price_points);

if(fatal)
{
    logger.Panic(
        PANIC_EXECUTION_INCONSIST,
        "Buy/Sell state mismatch detected"
    );
}
```

---

## 7. 重要な割り切り（Claudeへ）

* **ログの中身は後で変える**
* **設計が実装に引っ張られるのはOK**
* **今は「呼べること」が最優先**
* **CLA_Dataは触らない**

---

## 8. 成功条件（Claude自己チェック）

* [ ] enum LOG_ID を作っていない
* [ ] #define 仮IDを使っている
* [ ] Panicが文字列で出せる
* [ ] Flushが呼べる
* [ ] コンパイルが通る
* [ ] 将来削除・拡張できる

---

## 🧠 ChatGPTからの補足（Claude向け）

> これは完成品じゃない
> これは「足場」だ
> 足場は壊れなければいい
> 美しくなくていい

---

次はどっち行く？

* **A**：Claude実装が上がるのを待ってレビュー
* **B**：同時に「致命的に不足しているログ」を洗い出す
* **C**：Panic Snapshot の最小要件を決める

判断は任せる。

========================================

