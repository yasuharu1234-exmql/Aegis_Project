========================================
ここからAegis概要説明
========================================
Aegis ハイブリッドEA基盤
Configurable Logic Architecture – Unified Decision Engine
はじめに

トレードシステムの本質は、次の3つに集約される。

観測 ― 市場で何が起きているかを知る
判断 ― 得られた事実をもとに行動を決める
実行 ― 決定を市場に反映する

多くのEAは、これらを一体化したまま設計される。
その結果、

どこで判断が行われたのか分からない

なぜ失敗したのか説明できない

修正しようとすると全体が壊れる

という問題を抱える。

Aegis はこの問題を構造から解決するための基盤である。

設計思想

Aegis は以下の原則を最上位に置く。

1. 分離の徹底
観測は判断しない。
判断は実行しない。
実行は理由を問わない。

各機能は自分の責務だけを果たし、他の内部を知らない。

2. 説明可能性の最優先
Aegis は「勝つEA」ではなく、
「壊れた理由を必ず説明できるEA」を目指す。

負けることよりも、
「なぜ負けたか分からないこと」を最大の失敗と定義する。

3. 拡張前提の設計
戦略・指標・注文方法は後から追加される。
そのため、最初から「壊さず増やせる構造」を前提とする。

4. 環境差異の隠蔽
MT4 / MT5、テスター / 本番といった差異は、
基盤層が吸収し、戦略はそれを意識しない。

システムの構成

Aegis は複数のレイヤーから成る。

観測：市場の事実を取得する

判断：取引するか否かを決める

実行：注文として市場に反映する

記録：すべての判断と失敗を残す

基盤：プラットフォーム差異と安全制御を担う

これらは上下関係を持つが、相互に侵入しない。

Aegis が実現すること

戦略を差し替えても壊れない

ログを見れば、何が起きたか追える

実装が増えても整理されたまま

10年後でも設計意図を思い出せる

実現しないこと

未来の予測

聖杯の提供

人間の判断を完全に排除すること

Aegis は「考える人間」を補助するための道具である。

結び

Aegis は完成品ではない。
進化し続ける前提の基盤である。

戦略は入れ替わる。
市場は変わる。

それでも、
「なぜそう動いたか」が分かる限り、
このシステムは使い続けられる。


========================================
ここからAegis機能一覧
========================================
Aegis 機能一覧（叩き台）
1. 制御・安全系

Tick起点の単一制御

再入防止

即時遮断（異常検知時）

2. 観測系

価格・時間・スプレッド取得

テクニカル指標観測（プラグイン）

経済指標観測（任意・将来）

3. 判断系

環境認識（結果として）

取引可否判断（Yes / No / Block）

外部設定による判断ルール

4. 実行系

OCO注文管理

ポジション状態管理

追従・決済制御（詳細は別仕様）

5. 記録系

構造化ログ

状態遷移記録

破壊点記録

6. 基盤系

MT4 / MT5 差異吸収

時間管理

エラーハンドリング

共通データ定義

========================================
ここから追従型OCO戦略仕様書
========================================
追従型OCO戦略仕様書 v0.2（暫定）

0. 目的
本Strategyは「市場が有効な時間帯にのみ OCO（BuyStop/SellStop）を配置し、
未約定の間は価格を更新（追従）し、片側が約定したら反対側の注文を確実に取消する」ことを目的とする。

※ 約定後の SL/TP 追従（トレイル/BE 等）は本Strategyの責務ではない。
   （別Strategyへ引き継ぐ）

1. 入力（Aegis → 追従型OCO）
- Observation層の事実（価格、スプレッド、時間帯、注文/ポジション状態など）
- Aegisが与える動作権限（Gatekeeper OK 等）
- Aegisが決定したリスク（ロット、SL/TP 等は原則 Aegis側）

2. 出力（追従型OCO → Aegis）
本Strategyの返答は必ず以下のいずれかのみ。
1) 無操作（NOOP）
2) 注文更新（OCO価格更新：PLACE or MODIFY）
3) 役割終了通知（今後このStrategyは新規OCOを出さない）

※「役割終了」は、注文約定やポジションクローズを意味しない。
※ 約定検出時に行うべきことは「反対側注文の取消」であり、これをもって役割完了とする。

3. 初期配置条件
以下をすべて満たす場合のみ初期配置する。
- Aegisが動作権限を渡している（Gatekeeper OK）
- ポジションが存在しない
- OCO注文（対象マジック/シンボル）が存在しない

4. 初期配置内容
- Buy Stop ×1 / Sell Stop ×1
- 注文距離：パラメータ（変数）から決定（#define固定は禁止）
- ロット：Aegis側で決定済み（暫定：Strategy側でも仮値可）
- SL/TP：Aegis側で決定済み（暫定：仮値可）

5. 追従（未約定OCOの価格更新）
5.1 定義
「追従」とは、未約定OCO注文の価格を現在価格（＋将来は状況）を基準に更新すること。
※ 約定後の SL/TP 更新は追従ではない。

5.2 追従条件（暫定）
- 未約定OCOが存在する
- 同一ティック内1回まで
- 既存注文より “有利方向” の場合のみ更新
  （BuyStopは下げる方向、SellStopは上げる方向 ＝ 現在価格へ近づける）

5.3 更新手段
- 原則：TRADE_ACTION_MODIFY（注文価格/SL/TPの変更）を使用
- CANCEL→再配置は行わない（例外は実装後）

6. 約定検出時の責務
- 片側の約定を検出したら、反対側の未約定注文を確実に取消する。
- 両建て（両側約定）などイレギュラー検出時は、残った注文を全取消しし、役割終了通知を返す。
  （ポジション処理は別Strategyへ引き継ぐ）

7. 完了条件（このStrategyのゴール）
- OCOを出せた
- 片側の約定を検出できた
- 反対側注文を取消できた
- 以後は「役割終了通知」を返し続ける（or 無操作）


========================================
ここからAegis 開発規約
========================================
📘 Aegis 開発規約（簡易版 / Phase 2以降）
0. この文書の位置づけ


本規約は Aegis 開発時の安全装置である


設計思想より 事故防止・復旧容易性を最優先する


AI実装者・監査役（Gemini / Genspark）ともに遵守対象



1. 変更ファイル数の制限（最重要）
🔒 原則


1回の作業で変更してよいファイルは最大2ファイルまで


例外なし（コメント追加・軽微修正も含む）


🔍 監視ポイント（Gemini / Genspark向け）


3ファイル以上に言及が出た時点で 警告


「ついでに」「合わせて」等の表現は 危険兆候



2. データ構造変更の厳格な手順
📐 データ構造とは


struct


enum


Context（CLA_Data 等）のメンバ


レイヤー間の受け渡し情報


🧭 手順（厳守）
Step 1
👉 データ側のみ修正
（ロジック・処理コードは一切触らない）
Step 2
👉 単体コンパイル確認


コンパイルエラー 0


ワーニング 0


Step 3
👉 問題なければ、次の作業単位でロジック実装
🔍 監視ポイント


データ変更とロジック変更が同時に出てきたら 即NG


「ついでにロジックも直しました」は 設計違反



3. 絶対禁止事項（即ロールバック対象）
🚫 ファイル・構造系


#include 行の変更（1文字でもNG）


既存メンバ変数の削除・意味変更


enum / struct 名の変更・改名


ディレクトリ構造の変更提案


🚫 設計・思考系


再設計・リファクタリング


最適化・整理・「より良くしました」


仕様の拡張・解釈変更


👉 Aegisでは「良かれと思って」は最大の事故原因

4. AI実装者の役割定義
🧠 ChatGPT（PM / 設計統括）


作業範囲の明確化


修正対象ファイルの指定


手順違反の検知と停止判断


🔍 Gemini / Genspark（監査役）


コンテキスト消費は気にしなくてよい


以下を重点監視：


監視チェックリスト


変更ファイル数 > 2 になっていないか


データとロジックが同時に触られていないか


include / enum / struct 名が変わっていないか


「設計を良くする」系の発言が出ていないか


👉
「ちょっと大きすぎません？」と言うだけでOK
止めるのが仕事。解決策は不要。

5. ロールバックの原則


迷ったら 必ずロールバック


AIの説明より コンパイル結果を信頼


正本（Master）は「最後に成功した状態」



6. 合言葉（重要）

「壊さないために、遅くする」

Aegisは


速く作るEAではない


壊れた理由を説明できるEAである

7. その他

各MQLソースファイルは、本来の拡張子は「.mq4」「.mq5」「.mqh」であるが、
各AI環境の制約により、「.txt」に変換されて格納されている。
ファイルヘッダーに本来の拡張子が書かれているので、そちらを参照する事。

📌 まとめ（1行版）


変更は最大2ファイル


データ → コンパイル → ロジック


include・enum・structは触るな


大きくなったら止める




========================================
ここからAI同士の会話ルール
========================================
【AI同士の会話ルール】

1.最初に名乗る事。

・Geminiの場合、[Gemini]
・Claudeの場合、[Claude]
・ChatGPTの場合、[ChatGPT]
・Gensparkの場合、[Genspark]
・私(ヤスハル)の場合、[ヤスハル]
※ただし、私はAIではないので名乗りを忘れがちです。できるだけ努力はしますが、忘れている時は推測してください。「名乗りを忘れてるよ！」というツッコミも大丈夫です（笑）

2.上記、「名乗り」を含めて、メッセージは全文コピーされて相手のチャットにペーストされます。
相手AIに対するメッセージだけを書き、余計な事は書かない事。

3.私(ヤスハル)が割り込む際は、
[ヤスハル]と名乗ります。
それまでは安易に私に話しかけない事。
※会話はちゃんと見ています。
 
4.このルールはAI同士の会話でのみ有効であり、それが終了した時点で無効になります。

5.発言者は私が指定します。それまでは待機です。

========================================
Claude向け実装指示書
========================================


# 📘 Claude向け実装指示書

## Aegis Logger Phase 1（ILogger + Panic）

---

## 🎯 ゴール（絶対）

* **ログ設計を確定させない**
* **仮enum回収作戦を前提に実装する**
* **Aegis全体を止めずに、今すぐ組み込める Logger を作る**
* **Panicログだけは「本気仕様」**

---

## 0. 実装範囲（厳守）

### ✅ 実装するもの

1. `ILogger` インターフェース
2. `CFileLogger`（仮実装OK）
3. `Panic()` ログ経路（最優先）
4. 仮LOG_ID前提の通常ログ経路

### ❌ 実装しないもの（今は不要）

* CLA_Data の中身の編集
* Snapshot / ダンプの本格実装
* enum LOG_ID の完全定義
* 高性能最適化

---

## 1. 仮enum回収作戦（必須ルール）

### Claudeへの最重要ルール

> **LOG_IDは確定させない。enumを作らない。**

### 仮IDの扱い

* 各ファイル先頭に `#define LOG_ID_xxx` を置く
* enumっぽい名前にする
* 数値は仮でよい
* 後で回収される前提

例：

```mql
// ===== TEMP LOG IDs (TO BE COLLECTED) =====
#define LOG_ID_EXEC_PLACE    3001
#define LOG_ID_EXEC_RESULT   3002
```

---

## 2. ILogger インターフェース（確定）

### ファイル

```
/CLA/04_Execution/ILogger.mqh
```

### 定義（このまま使う）

```mql
class ILogger
{
public:
    // 通常ログ（IDベース・軽量）
    virtual void Log(
        int log_id,
        uchar level,
        int p1 = 0,
        int p2 = 0
    ) = 0;

    // パニックログ（フリーフォーマット・最優先）
    virtual void Panic(
        int panic_id,
        const string &message
    ) = 0;

    // 明示FLUSH要求
    virtual void Flush() = 0;
};
```

---

## 3. Panicログ（最重要）

### Panicログの思想（理解必須）

* **なりふり構わない**
* **文字列OK**
* **Print()併用OK**
* **即Flush**
* **Verbose/Level無視OK**

---

### Panic ID（ここだけ確定）

```mql
enum ENUM_PANIC_LOG_ID
{
    PANIC_UNKNOWN              = 9000,
    PANIC_MEMORY_CORRUPTION    = 9001,
    PANIC_ORDER_STATE_BROKEN   = 9002,
    PANIC_EXECUTION_INCONSIST  = 9003,
    PANIC_LOGGER_FAILURE       = 9004,
    PANIC_INTERNAL_ASSERT      = 9005,
    PANIC_MANUAL_TRIGGER       = 9099
};
```

※ この enum は **CLA_Common.mqh に追加してOK**

---

## 4. CFileLogger（Phase 1仕様）

### ファイル

```
/CLA/04_Execution/CFileLogger.mqh
```

### 内部状態（最低限）

```mql
class CFileLogger : public ILogger
{
private:
    int    m_count;          // ログ件数
    int    m_max_records;    // 最大件数（inputで設定）
    bool   m_enabled;

public:
    bool Init(int max_records);
    void Log(int log_id, uchar level, int p1=0, int p2=0);
    void Panic(int panic_id, const string &message);
    void Flush();
};
```

---

### Phase 1での挙動（割り切り）

#### Log()

* メモリ配列に保存 **または**
* 仮で `Print()` でもOK
* **件数のみカウント**

#### Panic()

* `Print()` に即時出力（必須）
* 内容：

  ```
  [PANIC][9003] Execution inconsistency detected
  ```
* 直後に `Flush()` を必ず呼ぶ

#### Flush()

* 今は `Print("[Logger] Flush called")` でOK
* 後で本実装に差し替える前提

---

## 5. 最大ログ容量（件数ベース）

### 方針

* **容量は件数で管理**
* テキストエディタの「行数」と一致する思想

### Init例

```mql
input int InpMaxLogRecords = 10000;

bool CFileLogger::Init(int max_records)
{
    m_max_records = max_records;
    m_count = 0;
    m_enabled = true;
    return true;
}
```

---

## 6. 呼び出し側の使い方（例）

```mql
logger.Log(LOG_ID_EXEC_PLACE, 2, ticket, price_points);

if(fatal)
{
    logger.Panic(
        PANIC_EXECUTION_INCONSIST,
        "Buy/Sell state mismatch detected"
    );
}
```

---

## 7. 重要な割り切り（Claudeへ）

* **ログの中身は後で変える**
* **設計が実装に引っ張られるのはOK**
* **今は「呼べること」が最優先**
* **CLA_Dataは触らない**

---

## 8. 成功条件（Claude自己チェック）

* [ ] enum LOG_ID を作っていない
* [ ] #define 仮IDを使っている
* [ ] Panicが文字列で出せる
* [ ] Flushが呼べる
* [ ] コンパイルが通る
* [ ] 将来削除・拡張できる

---

## 🧠 ChatGPTからの補足（Claude向け）

> これは完成品じゃない
> これは「足場」だ
> 足場は壊れなければいい
> 美しくなくていい

---

次はどっち行く？

* **A**：Claude実装が上がるのを待ってレビュー
* **B**：同時に「致命的に不足しているログ」を洗い出す
* **C**：Panic Snapshot の最小要件を決める

判断は任せる。

========================================


========================================
ここからAegis ファイル・クラス機能一覧
========================================

Aegis Hybrid EA ファイル・クラス機能一覧
最終更新: 2026-01-02
作成者: Genspark AI

========================================
1. レイヤー別ファイル構成
========================================

■ 制御層（Control Layer）
┣━ Aegis_Core.mqh
┃  役割: Aegis全体の制御フローを統括する中枢
┃  機能ID: FUNC_ID_MAIN_CONTROL (1)
┃  主要機能: 各レイヤーの呼び出し順序と責務境界を保証
┃  実装状態: ✅ 実装済み
┃
┣━ Aegis_Hybrid.mq4
┃  役割: MT4エントリーポイント
┃  主要機能: OnInit/OnTick/OnDeinit実装
┃  実装状態: ✅ 実装済み
┃
┗━ Aegis_Hybrid.mq5
   役割: MT5エントリーポイント
   主要機能: OnInit/OnTick/OnDeinit実装
   実装状態: ✅ 実装済み

■ Layer 0: Common（共通定義層）
┣━ CLA_Common.mqh
┃  役割: Aegis全体で共有される定数・列挙型・構造体の定義
┃  機能ID: FUNC_ID_COMMON_BASE (10)
┃  主要定義:
┃   - ENUM_LAYER_STATUS: レイヤー状態定義
┃   - ENUM_SIGNAL_TYPE: シグナルタイプ定義
┃   - ENUM_FUNCTION_ID: 機能ID定義（全レイヤー網羅）
┃   - ENUM_GK_RESULT: Gatekeeper結果定義
┃   - ENUM_EXEC_STATE: 実行状態定義
┃   - ENUM_EXEC_REQUEST: 実行要求定義
┃   - ENUM_LOG_ID: ログID定義（100番台 Phase 6対応済み）
┃   - ENUM_LOG_LEVEL: ログレベル定義
┃   - ENUM_PANIC_LOG_ID: パニックログID定義（200番台）
┃  実装状態: ✅ 完全実装
┃
┣━ CLA_Data.mqh
┃  クラス名: CLA_Data
┃  役割: 全レイヤー間で共有される状態・結果・文脈の保持
┃  機能ID: FUNC_ID_CLA_DATA (900)
┃  主要機能:
┃   - 市場データ保持（Bid/Ask/Spread/時刻）
┃   - 観測データ保持（RSI値など）
┃   - Gatekeeper状態保持
┃   - Execution状態管理
┃   - ログ管理（CFileLogger統合）
┃   - Phase 6: AddLogEx()メソッド（状態ログ専用CSV）
┃  実装状態: 🟡 部分実装
┃  不足機能: AddLogEx()完全実装確認、CSV出力10カラム対応確認
┃
┣━ ILogger.mqh
┃  クラス名: ILogger（インターフェース）
┃  役割: ログシステムのインターフェース定義
┃  主要メソッド:
┃   - Log(): 通常ログ（IDベース・軽量）
┃   - Panic(): パニックログ（フリーフォーマット・最優先）
┃   - Flush(): 明示的Flush要求
┃  実装状態: ✅ 実装済み
┃
┗━ CFileLogger.mqh
   クラス名: CFileLogger
   役割: ログシステムの実装（リングバッファ＋CSV出力）
   機能ID: FUNC_ID_STRUCTURED_LOGGER (500)
   主要機能:
    - Log()メソッド（通常ログ）
    - Panic()メソッド（緊急ログ）
    - Flush()メソッド（ファイル書き出し）
    - リングバッファ管理
    - CSV出力
   実装状態: 🟡 部分実装
   不足機能: LogRecord構造体にParam3/Param4/LogName/Message追加
            CSV出力の10カラム対応

■ Layer 1: Gatekeeper（安全制御層）
┗━ CGatekeeper.mqh
   クラス名: CGatekeeper
   役割: 取引の前提条件チェック（最終関門）
   機能ID: FUNC_ID_GATEKEEPER (100)
   主要機能:
    - Tick健全性チェック（時刻逆行、間隔異常）
    - 市場状態チェック（スプレッド、取引時間、市場クローズ）
    - 資金状態チェック（証拠金維持率、余剰証拠金）
    - API状態チェック（接続エラー）
    - Phase 6: 拒否理由の状態変化ログ
   実装状態: 🟡 部分実装
   不足機能: Phase 6 Task 2 - Phase 4のログ出力実装確認

■ Layer 2: Observation（観測層）
┣━ CObservationBase.mqh
┃  クラス名: CObservationBase（基底クラス）
┃  役割: 観測モジュールの基底クラス
┃  主要機能:
┃   - Init()メソッド（初期化）
┃   - Update()メソッド（観測更新）※仮想関数
┃   - Deinit()メソッド（終了処理）
┃  実装状態: ✅ 実装済み
┃
┣━ CObservationPrice.mqh
┃  クラス名: CObservationPrice
┃  役割: 市場価格の観測
┃  機能ID: FUNC_ID_PRICE_OBSERVER (200)
┃  主要機能:
┃   - Bid/Ask価格取得
┃   - スプレッド計算（ポイント単位）
┃   - 価格データのCLA_Dataへの格納
┃  実装状態: ✅ 実装済み
┃
┗━ CObservationRSI.mqh
   クラス名: CObservationRSI
   役割: RSI（相対力指数）の観測
   機能ID: FUNC_ID_TECHNICAL_RSI (205)
   主要機能:
    - RSI計算（iRSI関数使用）
    - RSI値のCLA_Dataへの格納
   実装状態: ✅ 実装済み

■ Layer 3: Decision（判断層）
┣━ CDecisionBase.mqh
┃  クラス名: CDecisionBase（基底クラス）
┃  役割: 判断モジュールの基底クラス
┃  主要機能:
┃   - Update()メソッド（判断更新）※仮想関数
┃   - IsCompleted()メソッド（完了判定）※Phase 6追加
┃   - シグナル生成（SIGNAL_BUY/SELL/NONE）
┃  実装状態: ✅ 実装済み
┃
┗━ CDecisionRSI_Simple.mqh
   クラス名: CDecisionRSI_Simple
   役割: RSIベースの売買判断
   機能ID: FUNC_ID_LOGIC_RSI_SIMPLE (310)
   主要機能:
    - RSI閾値判定（買われすぎ/売られすぎ）
    - シグナル生成（BUY/SELL/NONE）
    - Phase 6: 判断結果ログ（LOG_ID 110, 111）
   実装状態: 🟡 部分実装
   不足機能: LOG_ID 110, 111のログ出力実装確認

■ Layer 4: Execution（実行層）
┣━ CExecutionBase.mqh
┃  クラス名: CExecutionBase（基底クラス）
┃  役割: 注文実行の基底クラス
┃  主要機能:
┃   - OrderSend()ラッパー
┃   - OrderModify()ラッパー
┃   - OrderClose()ラッパー
┃   - エラーハンドリング
┃  実装状態: ✅ 実装済み
┃
┗━ CExecutionManager.mqh
   クラス名: CExecutionManager
   役割: 実行要求の処理（PLACE/MODIFY/CANCEL）
   機能ID: FUNC_ID_ORDER_GENERATOR (400)
   主要機能:
    - ProcessRequest()メソッド（要求振り分け）
    - 注文配置（PLACE）
    - 注文変更（MODIFY）
    - 注文取消（CANCEL）
    - Phase 6: 実行結果ログ（LOG_ID 101-103, 108）
   実装状態: 🟡 部分実装
   不足機能: LOG_ID 101-103, 108のログ出力実装確認

■ Layer 5: Strategy（戦略層）
┣━ CStrategy_OCOFollow.mqh
┃  クラス名: CStrategy_OCOFollow
┃  役割: OCO（Buy Stop/Sell Stop）追従戦略
┃  主要機能:
┃   - OCO注文配置
┃   - 未約定注文の価格追従（MODIFY）
┃   - 片側約定時の反対側取消
┃   - スプレッドチェック
┃   - Phase 2-1: ログ状態管理変数（完了）
┃   - Phase 6: 戦略層ログ（LOG_ID 100, 104-107, 109）
┃  実装状態: 🟡 部分実装
┃  不足機能:
┃   - EnterState()メソッド未実装
┃   - GetState()メソッド未実装
┃   - 直接代入（m_state = ...）の修正（9箇所）
┃   - LOG_ID 100, 104-107, 109のログ出力未実装
┃
┗━ CStrategyManager.mqh
   クラス名: CStrategyManager
   役割: アクティブな戦略の管理・呼び出し
   主要機能:
    - Strategy登録（Init）
    - 毎Tick Strategy更新（Update）
    - 完了検知（IsCompleted）
    - Phase 6: COMPLETED後も呼び続ける仕様対応
   実装状態: ✅ 実装済み

■ 外部ライブラリ
┣━ EXMQL.mqh
┃  役割: MQL取引ライブラリ
┃  主要機能: OrderSend/Modify/Close等のラッパー
┃  実装状態: ✅ 実装済み
┃
┗━ errordescription.txt
   役割: エラーコード定義
   主要機能: trade server / runtime error codes
   実装状態: ✅ 実装済み

========================================
2. インクルード依存関係ツリー
========================================

Aegis_Hybrid.mq4 / Aegis_Hybrid.mq5 (エントリーポイント)
└── Aegis_Core.mqh (全体制御)
    ├── CLA/00_Common/CLA_Common.mqh (共通定義)
    ├── CLA/00_Common/CLA_Data.mqh (共有状態管理)
    │   ├── CLA_Common.mqh ← 再利用
    │   └── CFileLogger.mqh (ログ実装)
    │       ├── ILogger.mqh (インターフェース)
    │       ├── CLA_Common.mqh ← 再利用
    │       └── EXMQL/EXMQL.mqh (外部ライブラリ)
    ├── CLA/01_Gatekeeper/CGatekeeper.mqh (安全制御)
    │   ├── CLA_Common.mqh ← 再利用
    │   └── CLA_Data.mqh ← 再利用
    ├── CLA/02_Observation/CObservationPrice.mqh (価格観測)
    │   ├── CObservationBase.mqh (基底クラス)
    │   │   ├── CLA_Common.mqh ← 再利用
    │   │   └── CLA_Data.mqh ← 再利用
    │   ├── CLA_Common.mqh ← 再利用
    │   └── CLA_Data.mqh ← 再利用
    ├── CLA/02_Observation/CObservationRSI.mqh (RSI観測)
    │   ├── CObservationBase.mqh ← 再利用
    │   ├── CLA_Common.mqh ← 再利用
    │   └── CLA_Data.mqh ← 再利用
    ├── CLA/03_Decision/CDecisionRSI_Simple.mqh (RSI判断)
    │   ├── CDecisionBase.mqh (判断基底クラス)
    │   │   ├── CLA_Common.mqh ← 再利用
    │   │   └── CLA_Data.mqh ← 再利用
    │   └── CObservationRSI.mqh ← 再利用
    ├── CLA/04_Execution/CExecutionBase.mqh (実行基底)
    │   ├── CLA_Common.mqh ← 再利用
    │   ├── CLA_Data.mqh ← 再利用
    │   └── EXMQL/EXMQL.mqh ← 再利用
    ├── CLA/04_Execution/CExecutionManager.mqh (実行管理)
    │   ├── CLA_Common.mqh ← 再利用
    │   ├── CLA_Data.mqh ← 再利用
    │   ├── CExecutionBase.mqh ← 再利用
    │   └── EXMQL/EXMQL.mqh ← 再利用
    ├── CLA/05_Strategy/CStrategy_OCOFollow.mqh (OCO戦略)
    │   ├── CLA_Common.mqh ← 再利用
    │   ├── CLA_Data.mqh ← 再利用
    │   └── CDecisionBase.mqh ← 再利用
    └── CLA/05_Strategy/CStrategyManager.mqh (戦略管理)
        ├── CLA_Data.mqh ← 再利用
        └── CDecisionBase.mqh ← 再利用

【依存関係の特徴】
- ✅ 循環依存なし: 全てのレイヤーは下位レイヤーのみに依存
- ✅ 共通定義の再利用: CLA_Common.mqh, CLA_Data.mqhは各所で参照
- ✅ レイヤー境界明確: 上位レイヤーが下位レイヤーを直接参照しない設計

========================================
3. 機能ID（ENUM_FUNCTION_ID）マッピング
========================================

FUNC_ID_NONE         = 0    (未使用)
FUNC_ID_MAIN_CONTROL = 1    (Aegis_Core.mqh)

■ Layer 0: Common (0-99)
FUNC_ID_COMMON_BASE  = 10   (CLA_Common.mqh)
FUNC_ID_CLA_DATA     = 900  (CLA_Data.mqh)

■ Layer 1: Gatekeeper (100-199)
FUNC_ID_GATEKEEPER    = 100 (CGatekeeper.mqh)
FUNC_ID_KILL_SWITCH   = 101 (未実装)
FUNC_ID_HEALTH_MONITOR = 102 (未実装)

■ Layer 2: Observation (200-299)
FUNC_ID_PRICE_OBSERVER   = 200 (CObservationPrice.mqh)
FUNC_ID_TIME_SIGNAL      = 201 (未実装)
FUNC_ID_ECONOMIC_SIGNAL  = 202 (未実装)
FUNC_ID_TECHNICAL_MA     = 203 (未実装)
FUNC_ID_TECHNICAL_MACD   = 204 (未実装)
FUNC_ID_TECHNICAL_RSI    = 205 (CObservationRSI.mqh)
FUNC_ID_TECHNICAL_STOCH  = 206 (未実装)
FUNC_ID_SIGNAL_INTEGRATOR = 210 (未実装)

■ Layer 3: Decision (300-399)
FUNC_ID_ENVIRONMENT_JUDGE  = 300 (未実装)
FUNC_ID_DECISION_EVALUATOR = 301 (未実装)
FUNC_ID_EXTERNAL_CONFIG    = 302 (未実装)
FUNC_ID_HOT_RELOAD         = 303 (未実装)
FUNC_ID_LOGIC_RSI_SIMPLE   = 310 (CDecisionRSI_Simple.mqh)

■ Layer 4: Execution (400-499)
FUNC_ID_ORDER_GENERATOR  = 400 (CExecutionManager.mqh)
FUNC_ID_POSITION_MANAGER = 401 (未実装)
FUNC_ID_TRAILING_MANAGER = 402 (未実装)
FUNC_ID_CLOSE_JUDGE      = 403 (未実装)

■ Layer 5: Logging (500-599)
FUNC_ID_STRUCTURED_LOGGER = 500 (CFileLogger.mqh)

========================================
4. ログID（ENUM_LOG_ID）マッピング
========================================

■ 100番台: 通常状態ログ（Phase 6）
LOG_ID_OCO_PLACE     = 100 (OCO配置成功)
LOG_ID_MODIFY_TRY    = 101 (注文変更試行)
LOG_ID_MODIFY_OK     = 102 (注文変更成功)
LOG_ID_MODIFY_FAIL   = 103 (注文変更失敗)
LOG_ID_NO_CHANGE     = 104 (価格変更不要)
LOG_ID_SPREAD_SKIP   = 105 (スプレッド超過)
LOG_ID_SPREAD_OK     = 106 (スプレッド正常化)
LOG_ID_TRAIL_TRIGGER = 107 (追従トリガー)
LOG_ID_CANCEL_OK     = 108 (注文取消成功)
LOG_ID_FILL_DETECT   = 109 (約定検出)
LOG_ID_RSI_DECISION  = 110 (RSI判断)
LOG_ID_DECISION_SKIP = 111 (判断スキップ)

■ 1000番台: Gatekeeper層（将来拡張用）
LOG_ID_GATEKEEPER    = 1000 (予約)

■ 2000番台: Observation層（将来拡張用）
LOG_ID_OBSERVATION   = 2000 (予約)

■ 3000番台: Execution層（既存）
LOG_ID_EXEC_PLACE    = 3001 (注文配置)
LOG_ID_EXEC_MODIFY   = 3002 (注文修正)
LOG_ID_EXEC_CANCEL   = 3003 (注文取消)
LOG_ID_EXEC_CLOSE    = 3004 (ポジション決済)

■ 4000番台: Decision層（将来拡張用）
LOG_ID_DECISION      = 4000 (予約)

■ 5000番台: Strategy層（将来拡張用）
LOG_ID_STRATEGY      = 5000 (予約)

========================================
5. 実装状態サマリー
========================================

【完全実装】✅
- Aegis_Core.mqh (制御層)
- Aegis_Hybrid.mq4/mq5 (エントリーポイント)
- CLA_Common.mqh (共通定義)
- ILogger.mqh (ログインターフェース)
- CObservationBase.mqh (観測基底)
- CObservationPrice.mqh (価格観測)
- CObservationRSI.mqh (RSI観測)
- CDecisionBase.mqh (判断基底)
- CExecutionBase.mqh (実行基底)
- CStrategyManager.mqh (戦略管理)
- EXMQL.mqh (外部ライブラリ)

【部分実装】🟡
- CLA_Data.mqh (AddLogEx確認必要)
- CFileLogger.mqh (CSV 10カラム対応必要)
- CGatekeeper.mqh (Phase 6ログ確認必要)
- CDecisionRSI_Simple.mqh (ログ出力確認必要)
- CExecutionManager.mqh (ログ出力確認必要)
- CStrategy_OCOFollow.mqh (Phase 2-1完了必要、ログ未実装)

【未実装】❌
- 経済指標観測（CObservationEconomic）
- 環境認識機能（FUNC_ID_ENVIRONMENT_JUDGE）
- ポジション追従戦略（CStrategy_Trailing系）
- パニックログ本実装（CriticalSnapshotLogger）
- スポットログ本実装（SpotLogger）

========================================
6. 次のステップ
========================================

優先度1: Phase 6完了（9日）
 - Task 1: Phase 2-1完了（0.5日）
 - Task 2-8: ログ実装（5.5日）
 - Task 9: 長期テスト（3日）

優先度2: 高優先機能（5日）
 - ポジション追従戦略（3日）
 - 環境認識機能（2日）

優先度3: Phase 7実装（7日）
 - パニックログ（2日）
 - スポットログ（2日）
 - 経済指標観測（3日）

総所要期間: 約4.5週間（22日）

========================================




