========================================
ここからAegis概要説明
========================================
Aegis ハイブリッドEA基盤
Configurable Logic Architecture – Unified Decision Engine
はじめに

トレードシステムの本質は、次の3つに集約される。

観測 ― 市場で何が起きているかを知る
判断 ― 得られた事実をもとに行動を決める
実行 ― 決定を市場に反映する

多くのEAは、これらを一体化したまま設計される。
その結果、

どこで判断が行われたのか分からない

なぜ失敗したのか説明できない

修正しようとすると全体が壊れる

という問題を抱える。

Aegis はこの問題を構造から解決するための基盤である。

設計思想

Aegis は以下の原則を最上位に置く。

1. 分離の徹底
観測は判断しない。
判断は実行しない。
実行は理由を問わない。

各機能は自分の責務だけを果たし、他の内部を知らない。

2. 説明可能性の最優先
Aegis は「勝つEA」ではなく、
「壊れた理由を必ず説明できるEA」を目指す。

負けることよりも、
「なぜ負けたか分からないこと」を最大の失敗と定義する。

3. 拡張前提の設計
戦略・指標・注文方法は後から追加される。
そのため、最初から「壊さず増やせる構造」を前提とする。

4. 環境差異の隠蔽
MT4 / MT5、テスター / 本番といった差異は、
基盤層が吸収し、戦略はそれを意識しない。

システムの構成

Aegis は複数のレイヤーから成る。

観測：市場の事実を取得する

判断：取引するか否かを決める

実行：注文として市場に反映する

記録：すべての判断と失敗を残す

基盤：プラットフォーム差異と安全制御を担う

これらは上下関係を持つが、相互に侵入しない。

Aegis が実現すること

戦略を差し替えても壊れない

ログを見れば、何が起きたか追える

実装が増えても整理されたまま

10年後でも設計意図を思い出せる

実現しないこと

未来の予測

聖杯の提供

人間の判断を完全に排除すること

Aegis は「考える人間」を補助するための道具である。

結び

Aegis は完成品ではない。
進化し続ける前提の基盤である。

戦略は入れ替わる。
市場は変わる。

それでも、
「なぜそう動いたか」が分かる限り、
このシステムは使い続けられる。


========================================
ここからAegis機能一覧
========================================
Aegis 機能一覧（叩き台）
1. 制御・安全系

Tick起点の単一制御

再入防止

即時遮断（異常検知時）

2. 観測系

価格・時間・スプレッド取得

テクニカル指標観測（プラグイン）

経済指標観測（任意・将来）

3. 判断系

環境認識（結果として）

取引可否判断（Yes / No / Block）

外部設定による判断ルール

4. 実行系

OCO注文管理

ポジション状態管理

追従・決済制御（詳細は別仕様）

5. 記録系

構造化ログ

状態遷移記録

破壊点記録

6. 基盤系

MT4 / MT5 差異吸収

時間管理

エラーハンドリング

共通データ定義

========================================
ここから追従型OCO戦略仕様書
========================================
================================================================================
追従型OCO戦略仕様書 v0.7（確定版）
最終更新: 2026-01-03
================================================================================

《ヤスハルの決定》（仕様書記載用・確定版）

【A】追従型OCO戦略の基本決定
────────────────────────────────────────────────────
A-1. 距離計算式
  決定内容：
    距離計算はポイント基準。Pips入力が必要な場合は初期入力時に
    Pointへ変換する。内部処理・判定・ログはすべてPointで統一する。
  理由：
    通貨ペア差異・小数桁差異による分岐を排除し、処理を単純化する。

A-2. 初期 SL / TP の計算式
  決定内容：
    初期SL: 固定値（変数）
    初期TP: 200 pips（確定）
    初期TPは十分に大きな「上限値」として扱い、利益確定はトレイルおよび
    TP圧縮ロジックに委ねる。
  補足：
    初期TPは「狙う値」ではなく「制限値」であり、トレイルが停滞した場合に
    TPを段階的に下げていく。

A-3. 更新間隔デフォルト
  決定内容：
    更新間隔はTick数ベース、デフォルト値は 50 Tick。
    更新間隔は変数化し、テスト/本番で調整可能とする。
  補足：
    更新間隔中の価格（最高値・最安値）の保持・比較は Strategy 内部で管理。

A-4. ロット計算式
  決定内容：
    当面は最小ロット固定。
    ロット計算ロジックは Strategy に含めず、将来の拡張を Execution 層へ委ねる。


================================================================================
0. 目的
================================================================================

本Strategyは以下を目的とする：

1) 市場が有効な時間帯（Gatekeeper判定）にのみOCO（両建て逆指値）を配置
2) 未約定の間は、価格変化に応じてOCO価格を追従更新
3) 片側約定時に反対側の未約定注文を取消し、役割を完了

SL/TPの追従（ブレイクイーブン、トレイル、決済準備）は別Strategyへ引き継ぐ。

《Strategy分割の方針》（確定）
  CStrategy_OCOFollow  : 初期配置 + 追従更新 + 約定検出
  CStrategy_BE         : BE制御（将来実装）
  CStrategy_Trailing   : トレイル + 決済（将来実装）


================================================================================
1. 入力（Aegis → 追従型OCO）
================================================================================

本Strategyは以下の情報を入力として受け取る：

1) Observation層からの事実
   - 現在価格（Ask/Bid）
   - スプレッド
   - 時間帯
   - 既存の注文/ポジション状態
   - その他市場情報

2) Aegisが与える動作権限
   - Gatekeeper OK（市場開いている、安全、API接続正常 等）

3) Aegisが決定したリスク
   - ロット
   - SL/TP（原則 Aegis側が決定、暫定は Strategy側で仮値可）


================================================================================
2. 出力（追従型OCO → Aegis）
================================================================================

本Strategyの返答は以下のいずれかのみ：

1) NOOP
   何もしない（待機状態）

2) 注文更新（OCO価格更新）
   PLACE: 新規OCO配置
   MODIFY: 既存OCO価格更新

3) 役割終了通知
   「今後このStrategyは新規OCOを出さない」という通知
   ※ 役割終了は注文約定やポジションクローズを意味しない
   ※ 約定検出時の反対側注文取消をもって役割完了とする

《取消処理の委任先》（確定）
  - Execution層へ委任（大前提）
  - 判断層は何も実行しない
  - 注文取消・ポジションクローズも実行層経由


================================================================================
3. 初期配置条件
================================================================================

以下の3条件がすべて満たされた場合に初期配置を実行：

条件1: Gatekeeper OK
  - 市場が開いている
  - スプレッドが正常範囲内
  - API接続が正常
  - 経済指標直前/直後ではない

条件2: ポジションなし
  - 既存ポジション数 == 0

条件3: OCO注文が存在しない
  - 既存OCO注文数 == 0


================================================================================
4. 初期配置内容
================================================================================

4.1 注文種別
  Buy Stop  ×1（Ask の上方に配置）
  Sell Stop ×1（Bid の下方に配置）

4.2 注文距離
  - パラメータから決定（固定値禁止）
  - Buy Stop 距離: A（変数）
  - Sell Stop 距離: B（変数）
  - 距離計算式: 未定（検証中、仮値での実装は可能）

4.3 ロット
  - Aegis決定済み
  - 暫定: Strategy側で仮値可
  - 確定値: 最小ロット固定

4.4 SL/TP
  - TP: 極大値（例: 200 pips、すぐに利確させないようにする）
  - SL: 少なめ（例: 20–30 pips）
  - 両注文とも変数で計算

具体例（USDJPY）:
  現在価格: Ask=150.00, Bid=149.98
  距離パラメータ: 10 pips = 0.10円
  Buy Stop  = 150.10（Ask + 0.10）
  Sell Stop = 149.88（Bid - 0.10）


================================================================================
5. 追従（未約定OCOの価格更新）
================================================================================

5.1 定義
  未約定OCOを現在価格へ追従（将来は状況に応じて更新）。
  約定後は追従対象外。

5.2 追従条件
  以下の条件をすべて満たす場合に更新：
    1) 未約定OCOが存在する
    2) 価格が変化した（前回MODIFY時の価格と異なる）

  価格変化がない場合は更新しない（API負荷軽減、ログ整理）。

5.3 更新間隔とパフォーマンス最適化
  デフォルト: 毎Tick更新
  運用時: 更新間隔を調整可能

  《更新間隔の2種類》
    A) 時間間隔: 10秒/1分/5分 等
    B) Tick数間隔: 10Tick/100Tick 等

  《確定値》
    - Tick数ベース
    - デフォルト: 50 Tick
    - 変数名例: InpFollowUpdateInterval
    - テスト/本番で調整可能

  《本番運用推奨値》
    - 50〜100 Tick
    - 通貨ペア別の調整は行わない（単純性優先）

  《実装方法》
    - Tick数カウンタを用意
    - 初期化時およびIDLE遷移時にリセット
    - 毎Tickカウントアップ
    - 設定間隔に達したら更新判定実行

  更新間隔が長いほど約定しやすく、短いほど約定しづらい。
  価格記録により「毎Tick更新と同等の追従効果」を狙う。

5.4 価格変化の記録
  前回MODIFY〜次回MODIFYの期間中の価格変化を内部記録：

  《記録内容》
    - 前回MODIFY時刻
    - 前回MODIFY時の価格（Ask/Bid）
    - 期間中の最高値（Ask）
    - 期間中の最安値（Bid）
    - 次回MODIFY時刻
    - 次回MODIFY時の価格（Ask/Bid）

  《記録場所》
    Strategy内部のメンバ変数として保持

  《記録タイミング》
    1. MODIFY成功時:
       - 前回MODIFY時刻・価格を現在値で更新
       - 期間中最高値・最安値を現在値でリセット

    2. MODIFY判定スキップ時（毎Tick）:
       - 現在価格を取得
       - 期間中最高値・最安値を更新（必要に応じて）

    3. IDLE遷移時:
       - 全記録値をリセット

  《目的》
    ノイズに負けない距離を計算し、更新頻度を下げつつ
    毎Tick更新と同等の追従効果を実現する。

  《活用方法》（将来実装）
    期間中の最高値・最安値を考慮した距離設定により、
    短期的な価格変動による不要な更新を回避。
    当面は記録のみ実施。

5.5 更新手段
  原則: TRADE_ACTION_MODIFY
  CANCEL→再配置は原則行わない。

5.6 約定の仕組み
  通常時: 距離を保ち、未約定のまま価格と並行移動
  大変動時: 距離を突破し、約定

  Buy Stop の約定条件:  Ask >= Buy Stop
  Sell Stop の約定条件: Bid <= Sell Stop

  更新間隔が長い → 約定しやすい
  更新間隔が短い → 約定しづらい

  価格記録により適切な距離を算定し、ノイズに負けない更新を行う。


================================================================================
6. 約定検出と取消処理
================================================================================

6.1 正常ケース（片側約定）
  処理:
    1) 片側の約定を検出
    2) 反対側の未約定注文を取消（Execution層経由）
    3) 役割完了状態へ遷移
    4) ポジション管理を別Strategyへ引き継ぎ

  ログ:
    LOG_ID_FILL_DETECT: 約定検出
    LOG_ID_CANCEL_OK: 取消成功

6.2 異常ケース（両側約定）
  処理:
    1) 両側約定を検出（イレギュラー）
    2) 反対側注文を全取消（存在すれば）
    3) 現在価格から遠い方のポジションを即クローズ
    4) 役割完了状態へ遷移
    5) 残ったポジションを別Strategyへ引き継ぎ

  《遠い方の判定》
    - 両ポジションの価格を取得
    - 現在価格との距離を計算
    - 距離が大きい方をクローズ対象とする

  ログ:
    PANIC_OCO_BOTH_FILLED（将来実装）

  《Panic条件》
    - EA停止は行わず、ログ記録のみ
    - 回復処理（Recovery）へ遷移

6.3 取消処理の委任先
  《確定》
    - Execution層へ委任
    - 判断層（Strategy）は何も実行しない


================================================================================
7. ブレイクイーブン（BE）制御 【将来実装】
================================================================================

《責務》
  BE制御は別Strategy（CStrategy_BE）の責務
  将来実装予定

7.1 BEの定義
  約定価格にスプレッドを加えた価格まで利益が出た時点で、
  SLを約定価格へ移動する。

7.2 BE達成条件
  Buy の場合:
    BE価格 = 約定価格 + スプレッド（約定時）
    現在価格（Bid）>= BE価格
    → SLを約定価格へ更新

  Sell の場合:
    BE価格 = 約定価格 - スプレッド（約定時）
    現在価格（Ask）<= BE価格
    → SLを約定価格へ更新

7.3 SL更新処理
  BE達成後、SLを約定価格へ更新（利益がゼロでもOK）。

  《スプレッドの割り切り》
    BE達成時のスプレッド: 3 pips
    SL更新後のスプレッド: 5 pips
    → 実質的な決済価格は若干不利になる可能性あり
    → パフォーマンス優先で割り切る

7.4 ログ出力
  将来実装時に以下のログを追加予定:
    LOG_ID_BE_CHECK    : BE達成チェック
    LOG_ID_BE_ACHIEVED : BE達成
    LOG_ID_SL_UPDATED  : SL更新成功

《BE部分の分割》
  - BE制御は CStrategy_BE として分離
  - 追従戦略（CStrategy_Trailing）とは独立


================================================================================
8. トレイル制御 【将来実装】
================================================================================

《責務》
  トレイル制御は別Strategy（CStrategy_Trailing）の責務
  将来実装予定

8.1 定義
  BE確保後、価格が有利方向に進んだ場合にSLを追従させる。

8.2 トレイル開始条件
  1) BE確保済み（SL = 約定価格）
  2) 現在価格が有利方向に一定距離以上進んだ

  《確定値》
    - 距離: 固定値（変数）
    - ATR等の動的指標は使用しない

8.3 トレイル更新の距離
  《確定値》
    - トレイル更新距離: 固定値（変数）
    - ATR等の動的指標は使用しない

  更新例（Buy の場合）:
    約定価格: 150.10
    BE確保:   SL = 150.10
    価格上昇: Bid = 150.20
    トレイル: SL = 150.15（+5 pips）
    価格上昇: Bid = 150.30
    トレイル: SL = 150.25（+5 pips）

8.4 停滞検出
  トレイルが一定期間動かない場合、「停滞」と判定。

  《確定値》
    - 判定基準: 「トレイル判定が呼ばれた回数」
    - SLが更新されない回数が 10回 で停滞と判定
    - 変数名例: InpTrailStagnationCount
    - 以後も 10回毎に同様の判定を行う

8.5 ログ出力
  将来実装時に以下のログを追加予定:
    LOG_ID_TRAIL_START : トレイル開始
    LOG_ID_TRAIL_UPDATE: SL更新成功
    LOG_ID_TRAIL_STALL : 停滞検出


================================================================================
9. 決済準備と完了 【将来実装】
================================================================================

《責務》
  決済準備は CStrategy_Trailing の責務
  将来実装予定

《SLの性質に関する前提》

  SLはサーバ側で保証される価格ではない。
  急激な価格変動（ギャップ、スリッページ等）により、
  現在価格がSLを飛び越えた場合、想定した価格で決済されない
  可能性がある。

  本Strategyおよび後続Strategyは以下を前提とする：

    - SLは「損失限定の目安」であり、絶対的な保証ではない
    - SLを超過した損失が発生する可能性を許容する
    - 異常な乖離が検出された場合は Panic Log の対象とする

9.1 TPを徐々に下げる
  トレイル停滞を検出した場合、TPを段階的に下げる（TP圧縮）。

  《確定値》
    計算式:
      新TP = (現在のTP + トレイル間隔中の高値) / 2

    制約:
      - TPとSLの最小距離を確保（例: 5 pips、変数）
      - 変数名例: InpMinTPDistance

    トレイル再開時:
      - 停滞カウントをリセット
      - TP圧縮を一時停止

    補足:
      - TP圧縮の発生は必ずログに記録

  例（Buy の場合）:
    初期TP: 150.50
    停滞1: TP → 150.40（-10 pips）
    停滞2: TP → 150.35（-5 pips）
    停滞3: TP → 150.32（-3 pips）

9.2 決済パターン
  パターンA: SL決済
    トレイルしたSLに価格が到達 → 決済

  パターンB: TP決済
    圧縮したTPに価格が到達 → 決済

  決済後:
    1) ログ出力
    2) 初期状態へ復帰
    3) 次のサイクルへ（初期配置条件チェック）

9.3 ログ出力
  将来実装時に以下のログを追加予定:
    LOG_ID_TP_COMPRESS  : TP圧縮実行
    LOG_ID_POSITION_CLOSE: ポジション決済
    LOG_ID_CYCLE_RESTART: サイクル再開


================================================================================
10. 全体の状態遷移
================================================================================

《STATE定義の原則》

  STATEは「現在の戦略状態」を示すものであり、
  Actionの結果やエラー内容そのものを表すものではない。

    - Action（実行指示）は常に1 Tick に1つ
    - Result（実行結果）は複数存在しうる
    - Resultは判断層で解釈され、唯一のSTATEへ変換される
    - STATEは常に一意である
    - 補助フラグ（回数カウンタ等）はSTATEとは別に保持してよい


10.1 STATE定義

  OCO_STATE_IDLE      : 未配置状態
  OCO_STATE_ACTIVE    : OCO配置済み・追従中
  OCO_STATE_COMPLETED : 役割完了


10.2 正常フロー

  [OCO_STATE_IDLE]
    ↓ 初期配置条件チェック（3条件すべてOK）
    ↓ 配置要求をExecution層へ送信
    ↓
  [OCO_STATE_ACTIVE] ←┐
    ↓                 │
    ├─ 価格変化検出    │
    ├─ MODIFY要求送信  │
    └─────────────────┘
    ↓ 片側約定検出
    ↓ 取消要求をExecution層へ送信
    ↓
  [OCO_STATE_COMPLETED]
    ↓ ポジションクローズ検出
    ↓
  [OCO_STATE_IDLE]（次のサイクル）


10.3 イレギュラーケース1: 両側約定

  [OCO_STATE_ACTIVE]
    ↓ 両側約定検出（PANIC_OCO_BOTH_FILLED）
  [Recovery処理]
    - 全注文取消
    - 遠い方のポジをクローズ
    ↓
  [OCO_STATE_COMPLETED]
    ↓ 残ったポジションを別Strategyへ
  [OCO_STATE_IDLE]


10.4 イレギュラーケース2: 取消失敗

  [OCO_STATE_ACTIVE]
    ↓ 反対側取消失敗
  [Retry処理]（Execution層）
    - ティック内リトライ（Sleep許容）
    - 最大回数: 10回（変数例: InpMaxRetryCount）
    ↓ 最大回数超過
  [Recovery → Panic]
    - PANIC_CANCEL_FAILED
    - EA停止

  《Panic条件》
    - 即時停止はしない
    - ティック内リトライ（Sleep許容）を実行
    - 最大回数超過時のみ: Recovery → Panic → EA停止


10.5 イレギュラーケース3: スプレッド異常

  [OCO_STATE_ACTIVE]
    ↓ スプレッド異常検出（> 100 pips）
  [スキップ処理]
    - 今回の更新をスキップ
    - LOG_ID_SPREAD_SKIP
    ↓ 次のTick
  [OCO_STATE_ACTIVE]（継続）

  《スプレッド異常の判定》
    - 閾値: 100 pips（変数例: InpSpreadThreshold）
    - 単なる拡大では停止しない
    - 明確に異常と判断できる場合のみ対象


10.6 イレギュラーケース4: Gatekeeper拒否

  [OCO_STATE_IDLE]
    ↓ Gatekeeper NG（市場休場、スプレッド異常等）
  [OCO_STATE_IDLE]（待機継続）
    ↓ 次のTick
  [OCO_STATE_IDLE]（条件チェック繰り返し）


10.7 状態遷移図（ASCII）

  [IDLE] ─(条件OK)─> [ACTIVE] ←┐
    ↑                    ↓       │
    │                 (価格変化)  │
    │                    ↓       │
    │                 [MODIFY] ──┘
    │                    ↓
    │                 (約定検出)
    │                    ↓
    │               [COMPLETED]
    │                    ↓
    └───(ポジション決済)──┘

  [例外処理]
    [ACTIVE] ─(両側約定)─> [Recovery] ─> [COMPLETED]
    [ACTIVE] ─(取消失敗)─> [Retry×10] ─> [Panic] ─> [停止]
    [ACTIVE] ─(スプレッド)> [Skip]    ─> [ACTIVE]


================================================================================
11. ログ出力（統合ログ機構）
================================================================================

11.1 現在実装済み（100番台）

  LOG_ID_OCO_PLACE    (100): OCO配置実行
  LOG_ID_MODIFY_TRY   (101): MODIFY試行
  LOG_ID_MODIFY_OK    (102): MODIFY成功
  LOG_ID_MODIFY_FAIL  (103): MODIFY失敗
  LOG_ID_NO_CHANGE    (104): 価格変化なし（更新スキップ）
  LOG_ID_SPREAD_SKIP  (105): スプレッド異常（更新スキップ）
  LOG_ID_SPREAD_OK    (106): スプレッド正常確認
  LOG_ID_TRAIL_TRIGGER(107): トレイル開始トリガー
  LOG_ID_CANCEL_OK    (108): 取消成功
  LOG_ID_FILL_DETECT  (109): 約定検出

  形式: 10列 CSV
  出力関数: AddLogEx()


11.2 将来実装予定

  《BE制御関連》
    LOG_ID_BE_CHECK    : BE達成チェック
    LOG_ID_BE_ACHIEVED : BE達成
    LOG_ID_SL_UPDATED  : SL更新成功

  《トレイル関連》
    LOG_ID_TRAIL_START : トレイル開始
    LOG_ID_TRAIL_UPDATE: SL更新成功
    LOG_ID_TRAIL_STALL : 停滞検出

  《決済関連》
    LOG_ID_TP_COMPRESS  : TP圧縮実行
    LOG_ID_POSITION_CLOSE: ポジション決済
    LOG_ID_CYCLE_RESTART: サイクル再開

  《異常系》
    PANIC_OCO_BOTH_FILLED : 両側約定検出
    PANIC_CANCEL_FAILED   : 取消失敗（最大回数超過）


================================================================================
12. 実装計画と優先順位
================================================================================

12.1 【必須実装】追従型OCO基本機能

対象ファイル: CStrategy_OCOFollow.mqh

実装内容:
  1) Execution層経由への変更
     判断層は実行を行わず、Execution層へ要求を委任

  2) 価格変化記録の追加
     記録内容:
       - 前回MODIFY時刻
       - 前回MODIFY時の価格（Ask/Bid）
       - 期間中の最高値（Ask）
       - 期間中の最安値（Bid）
     
     初期化: コンストラクタおよびリセット時

  3) 更新間隔制御
     Tick数カウンタを用意し、設定間隔毎に更新判定を実行

  4) ログ出力（統合ログ機構）
     統合ログ機構を使用してログを出力

  5) STATE遷移実装
     OCO_STATE_IDLE → OCO_STATE_ACTIVE → OCO_STATE_COMPLETED

完了条件:
  - 全機能動作確認
  - コンパイルエラー/警告 0
  - 既存テストケース全通過


12.2 【将来実装】BE/トレイル制御

対象ファイル: CStrategy_BE.mqh / CStrategy_Trailing.mqh（新規作成）

実装内容:
  - BE制御: ブレイクイーブン達成時のSL更新
  - トレイル制御: 利益追従とTP圧縮
  - 決済準備: トレイル停滞検出とTP段階的低下

実装時期: 追従型OCO基本機能完成後


12.3 【将来実装】Panic/Recovery機構

実装内容:
  - PANIC_OCO_BOTH_FILLED: 両側約定検出
  - PANIC_CANCEL_FAILED: 取消失敗（リトライ超過）
  - OnDeinit時の最終処理（ベストエフォート）

実装時期: 基本機能安定後


12.4 確定した設計パラメータ

  《変数名と推奨値》
    InpFollowUpdateInterval  : 50 Tick（更新間隔）
    InpTrailStagnationCount  : 10回（停滞判定）
    InpMaxRetryCount         : 10回（リトライ最大回数）
    InpSpreadThreshold       : 100 pips（スプレッド閾値）
    InpMinTPDistance         : 5 pips（TP/SL最小距離）

  《本番運用推奨値》
    - 更新間隔: 50〜100 Tick
    - 通貨ペア別の調整は行わない（単純性優先）


12.5 Panic/Recovery ルール

  《基本方針》
    - ティック内でのリトライを許容
    - Sleep使用を許容
    - 最大回数: 10回
    - 超過時: RECOVERY → PANIC → EA停止

  《個別Panic条件》
    PANIC_OCO_BOTH_FILLED:
      - EA停止は行わず、ログ記録のみ
      - Recovery処理へ遷移

    PANIC_CANCEL_FAILED:
      - 即時停止はしない
      - ティック内リトライ（Sleep許容）
      - 最大回数超過時のみ: Recovery → Panic → EA停止

  《削除された設計》
    - CANCEL_FAILED STATE は不要（削除）
    - STATEは常に唯一（補助フラグ併用は許可）

  《最終原則》
    - 1 Tickに実行されるActionは常に1つ
    - OnDeinit時は最終処理を必ず実行
    - 不完全な終了より説明可能な停止を選ぶ

  《OnDeinit時の最終処理》

    EA終了時（正常・異常を問わず）、以下を必ず実行する：

      1) 存在する全未約定注文の取消
      2) 存在する全ポジションのクローズ試行
      3) 実行された処理内容をログに記録（可能であれば）

    これは「最後の悪あがき」であり、
    成功・失敗に関わらず実行することを原則とする。

    不完全な終了よりも、説明可能な停止を優先する。




========================================
ここからAegis 開発規約
========================================
📘 Aegis 開発規約（簡易版 / Phase 2以降）
0. この文書の位置づけ


本規約は Aegis 開発時の安全装置である


設計思想より 事故防止・復旧容易性を最優先する


AI実装者・監査役（Gemini / Genspark）ともに遵守対象



1. 変更ファイル数の制限（最重要）
🔒 原則


1回の作業で変更してよいファイルは最大2ファイルまで


例外なし（コメント追加・軽微修正も含む）


🔍 監視ポイント（Gemini / Genspark向け）


3ファイル以上に言及が出た時点で 警告


「ついでに」「合わせて」等の表現は 危険兆候



2. データ構造変更の厳格な手順
📐 データ構造とは


struct


enum


Context（CLA_Data 等）のメンバ


レイヤー間の受け渡し情報


🧭 手順（厳守）
Step 1
👉 データ側のみ修正
（ロジック・処理コードは一切触らない）
Step 2
👉 単体コンパイル確認


コンパイルエラー 0


ワーニング 0


Step 3
👉 問題なければ、次の作業単位でロジック実装
🔍 監視ポイント


データ変更とロジック変更が同時に出てきたら 即NG


「ついでにロジックも直しました」は 設計違反



3. 絶対禁止事項（即ロールバック対象）
🚫 ファイル・構造系


#include 行の変更（1文字でもNG）


既存メンバ変数の削除・意味変更


enum / struct 名の変更・改名


ディレクトリ構造の変更提案


🚫 設計・思考系


再設計・リファクタリング


最適化・整理・「より良くしました」


仕様の拡張・解釈変更


👉 Aegisでは「良かれと思って」は最大の事故原因

4. AI実装者の役割定義
🧠 ChatGPT（PM / 設計統括）


作業範囲の明確化


修正対象ファイルの指定


手順違反の検知と停止判断


🔍 Gemini / Genspark（監査役）


コンテキスト消費は気にしなくてよい


以下を重点監視：


監視チェックリスト


変更ファイル数 > 2 になっていないか


データとロジックが同時に触られていないか


include / enum / struct 名が変わっていないか


「設計を良くする」系の発言が出ていないか


👉
「ちょっと大きすぎません？」と言うだけでOK
止めるのが仕事。解決策は不要。

5. ロールバックの原則


迷ったら 必ずロールバック


AIの説明より コンパイル結果を信頼


正本（Master）は「最後に成功した状態」



6. 合言葉（重要）

「壊さないために、遅くする」

Aegisは


速く作るEAではない


壊れた理由を説明できるEAである

7. その他

各MQLソースファイルは、本来の拡張子は「.mq4」「.mq5」「.mqh」であるが、
各AI環境の制約により、「.txt」に変換されて格納されている。
ファイルヘッダーに本来の拡張子が書かれているので、そちらを参照する事。

📌 まとめ（1行版）


変更は最大2ファイル


データ → コンパイル → ロジック


include・enum・structは触るな


大きくなったら止める




========================================
ここからAI同士の会話ルール
========================================
【AI同士の会話ルール】

1.最初に名乗る事。

・Geminiの場合、[Gemini]
・Claudeの場合、[Claude]
・ChatGPTの場合、[ChatGPT]
・Gensparkの場合、[Genspark]
・私(ヤスハル)の場合、[ヤスハル]
※ただし、私はAIではないので名乗りを忘れがちです。できるだけ努力はしますが、忘れている時は推測してください。「名乗りを忘れてるよ！」というツッコミも大丈夫です（笑）

2.上記、「名乗り」を含めて、メッセージは全文コピーされて相手のチャットにペーストされます。
相手AIに対するメッセージだけを書き、余計な事は書かない事。

3.私(ヤスハル)が割り込む際は、
[ヤスハル]と名乗ります。
それまでは安易に私に話しかけない事。
※会話はちゃんと見ています。
 
4.このルールはAI同士の会話でのみ有効であり、それが終了した時点で無効になります。

5.発言者は私が指定します。それまでは待機です。

========================================
Claude向け実装指示書
========================================


# 📘 Claude向け実装指示書

## Aegis Logger Phase 1（ILogger + Panic）

---

## 🎯 ゴール（絶対）

* **ログ設計を確定させない**
* **仮enum回収作戦を前提に実装する**
* **Aegis全体を止めずに、今すぐ組み込める Logger を作る**
* **Panicログだけは「本気仕様」**

---

## 0. 実装範囲（厳守）

### ✅ 実装するもの

1. `ILogger` インターフェース
2. `CFileLogger`（仮実装OK）
3. `Panic()` ログ経路（最優先）
4. 仮LOG_ID前提の通常ログ経路

### ❌ 実装しないもの（今は不要）

* CLA_Data の中身の編集
* Snapshot / ダンプの本格実装
* enum LOG_ID の完全定義
* 高性能最適化

---

## 1. 仮enum回収作戦（必須ルール）

### Claudeへの最重要ルール

> **LOG_IDは確定させない。enumを作らない。**

### 仮IDの扱い

* 各ファイル先頭に `#define LOG_ID_xxx` を置く
* enumっぽい名前にする
* 数値は仮でよい
* 後で回収される前提

例：

```mql
// ===== TEMP LOG IDs (TO BE COLLECTED) =====
#define LOG_ID_EXEC_PLACE    3001
#define LOG_ID_EXEC_RESULT   3002
```

---

## 2. ILogger インターフェース（確定）

### ファイル

```
/CLA/04_Execution/ILogger.mqh
```

### 定義（このまま使う）

```mql
class ILogger
{
public:
    // 通常ログ（IDベース・軽量）
    virtual void Log(
        int log_id,
        uchar level,
        int p1 = 0,
        int p2 = 0
    ) = 0;

    // パニックログ（フリーフォーマット・最優先）
    virtual void Panic(
        int panic_id,
        const string &message
    ) = 0;

    // 明示FLUSH要求
    virtual void Flush() = 0;
};
```

---

## 3. Panicログ（最重要）

### Panicログの思想（理解必須）

* **なりふり構わない**
* **文字列OK**
* **Print()併用OK**
* **即Flush**
* **Verbose/Level無視OK**

---

### Panic ID（ここだけ確定）

```mql
enum ENUM_PANIC_LOG_ID
{
    PANIC_UNKNOWN              = 9000,
    PANIC_MEMORY_CORRUPTION    = 9001,
    PANIC_ORDER_STATE_BROKEN   = 9002,
    PANIC_EXECUTION_INCONSIST  = 9003,
    PANIC_LOGGER_FAILURE       = 9004,
    PANIC_INTERNAL_ASSERT      = 9005,
    PANIC_MANUAL_TRIGGER       = 9099
};
```

※ この enum は **CLA_Common.mqh に追加してOK**

---

## 4. CFileLogger（Phase 1仕様）

### ファイル

```
/CLA/04_Execution/CFileLogger.mqh
```

### 内部状態（最低限）

```mql
class CFileLogger : public ILogger
{
private:
    int    m_count;          // ログ件数
    int    m_max_records;    // 最大件数（inputで設定）
    bool   m_enabled;

public:
    bool Init(int max_records);
    void Log(int log_id, uchar level, int p1=0, int p2=0);
    void Panic(int panic_id, const string &message);
    void Flush();
};
```

---

### Phase 1での挙動（割り切り）

#### Log()

* メモリ配列に保存 **または**
* 仮で `Print()` でもOK
* **件数のみカウント**

#### Panic()

* `Print()` に即時出力（必須）
* 内容：

  ```
  [PANIC][9003] Execution inconsistency detected
  ```
* 直後に `Flush()` を必ず呼ぶ

#### Flush()

* 今は `Print("[Logger] Flush called")` でOK
* 後で本実装に差し替える前提

---

## 5. 最大ログ容量（件数ベース）

### 方針

* **容量は件数で管理**
* テキストエディタの「行数」と一致する思想

### Init例

```mql
input int InpMaxLogRecords = 10000;

bool CFileLogger::Init(int max_records)
{
    m_max_records = max_records;
    m_count = 0;
    m_enabled = true;
    return true;
}
```

---

## 6. 呼び出し側の使い方（例）

```mql
logger.Log(LOG_ID_EXEC_PLACE, 2, ticket, price_points);

if(fatal)
{
    logger.Panic(
        PANIC_EXECUTION_INCONSIST,
        "Buy/Sell state mismatch detected"
    );
}
```

---

## 7. 重要な割り切り（Claudeへ）

* **ログの中身は後で変える**
* **設計が実装に引っ張られるのはOK**
* **今は「呼べること」が最優先**
* **CLA_Dataは触らない**

---

## 8. 成功条件（Claude自己チェック）

* [ ] enum LOG_ID を作っていない
* [ ] #define 仮IDを使っている
* [ ] Panicが文字列で出せる
* [ ] Flushが呼べる
* [ ] コンパイルが通る
* [ ] 将来削除・拡張できる

---

## 🧠 ChatGPTからの補足（Claude向け）

> これは完成品じゃない
> これは「足場」だ
> 足場は壊れなければいい
> 美しくなくていい

---

次はどっち行く？

* **A**：Claude実装が上がるのを待ってレビュー
* **B**：同時に「致命的に不足しているログ」を洗い出す
* **C**：Panic Snapshot の最小要件を決める

判断は任せる。

========================================


========================================
ここからAegis ファイル・クラス機能一覧
========================================

Aegis Hybrid EA ファイル・クラス機能一覧
最終更新: 2026-01-02
作成者: Genspark AI

========================================
1. レイヤー別ファイル構成
========================================

■ 制御層（Control Layer）
┣━ Aegis_Core.mqh
┃  役割: Aegis全体の制御フローを統括する中枢
┃  機能ID: FUNC_ID_MAIN_CONTROL (1)
┃  主要機能: 各レイヤーの呼び出し順序と責務境界を保証
┃  実装状態: ✅ 実装済み
┃
┣━ Aegis_Hybrid.mq4
┃  役割: MT4エントリーポイント
┃  主要機能: OnInit/OnTick/OnDeinit実装
┃  実装状態: ✅ 実装済み
┃
┗━ Aegis_Hybrid.mq5
   役割: MT5エントリーポイント
   主要機能: OnInit/OnTick/OnDeinit実装
   実装状態: ✅ 実装済み

■ Layer 0: Common（共通定義層）
┣━ CLA_Common.mqh
┃  役割: Aegis全体で共有される定数・列挙型・構造体の定義
┃  機能ID: FUNC_ID_COMMON_BASE (10)
┃  主要定義:
┃   - ENUM_LAYER_STATUS: レイヤー状態定義
┃   - ENUM_SIGNAL_TYPE: シグナルタイプ定義
┃   - ENUM_FUNCTION_ID: 機能ID定義（全レイヤー網羅）
┃   - ENUM_GK_RESULT: Gatekeeper結果定義
┃   - ENUM_EXEC_STATE: 実行状態定義
┃   - ENUM_EXEC_REQUEST: 実行要求定義
┃   - ENUM_LOG_ID: ログID定義（100番台 Phase 6対応済み）
┃   - ENUM_LOG_LEVEL: ログレベル定義
┃   - ENUM_PANIC_LOG_ID: パニックログID定義（200番台）
┃  実装状態: ✅ 完全実装
┃
┣━ CLA_Data.mqh
┃  クラス名: CLA_Data
┃  役割: 全レイヤー間で共有される状態・結果・文脈の保持
┃  機能ID: FUNC_ID_CLA_DATA (900)
┃  主要機能:
┃   - 市場データ保持（Bid/Ask/Spread/時刻）
┃   - 観測データ保持（RSI値など）
┃   - Gatekeeper状態保持
┃   - Execution状態管理
┃   - ログ管理（CFileLogger統合）
┃   - Phase 6: AddLogEx()メソッド（状態ログ専用CSV）
┃  実装状態: 🟡 部分実装
┃  不足機能: AddLogEx()完全実装確認、CSV出力10カラム対応確認
┃
┣━ ILogger.mqh
┃  クラス名: ILogger（インターフェース）
┃  役割: ログシステムのインターフェース定義
┃  主要メソッド:
┃   - Log(): 通常ログ（IDベース・軽量）
┃   - Panic(): パニックログ（フリーフォーマット・最優先）
┃   - Flush(): 明示的Flush要求
┃  実装状態: ✅ 実装済み
┃
┗━ CFileLogger.mqh
   クラス名: CFileLogger
   役割: ログシステムの実装（リングバッファ＋CSV出力）
   機能ID: FUNC_ID_STRUCTURED_LOGGER (500)
   主要機能:
    - Log()メソッド（通常ログ）
    - Panic()メソッド（緊急ログ）
    - Flush()メソッド（ファイル書き出し）
    - リングバッファ管理
    - CSV出力
   実装状態: 🟡 部分実装
   不足機能: LogRecord構造体にParam3/Param4/LogName/Message追加
            CSV出力の10カラム対応

■ Layer 1: Gatekeeper（安全制御層）
┗━ CGatekeeper.mqh
   クラス名: CGatekeeper
   役割: 取引の前提条件チェック（最終関門）
   機能ID: FUNC_ID_GATEKEEPER (100)
   主要機能:
    - Tick健全性チェック（時刻逆行、間隔異常）
    - 市場状態チェック（スプレッド、取引時間、市場クローズ）
    - 資金状態チェック（証拠金維持率、余剰証拠金）
    - API状態チェック（接続エラー）
    - Phase 6: 拒否理由の状態変化ログ
   実装状態: 🟡 部分実装
   不足機能: Phase 6 Task 2 - Phase 4のログ出力実装確認

■ Layer 2: Observation（観測層）
┣━ CObservationBase.mqh
┃  クラス名: CObservationBase（基底クラス）
┃  役割: 観測モジュールの基底クラス
┃  主要機能:
┃   - Init()メソッド（初期化）
┃   - Update()メソッド（観測更新）※仮想関数
┃   - Deinit()メソッド（終了処理）
┃  実装状態: ✅ 実装済み
┃
┣━ CObservationPrice.mqh
┃  クラス名: CObservationPrice
┃  役割: 市場価格の観測
┃  機能ID: FUNC_ID_PRICE_OBSERVER (200)
┃  主要機能:
┃   - Bid/Ask価格取得
┃   - スプレッド計算（ポイント単位）
┃   - 価格データのCLA_Dataへの格納
┃  実装状態: ✅ 実装済み
┃
┗━ CObservationRSI.mqh
   クラス名: CObservationRSI
   役割: RSI（相対力指数）の観測
   機能ID: FUNC_ID_TECHNICAL_RSI (205)
   主要機能:
    - RSI計算（iRSI関数使用）
    - RSI値のCLA_Dataへの格納
   実装状態: ✅ 実装済み

■ Layer 3: Decision（判断層）
┣━ CDecisionBase.mqh
┃  クラス名: CDecisionBase（基底クラス）
┃  役割: 判断モジュールの基底クラス
┃  主要機能:
┃   - Update()メソッド（判断更新）※仮想関数
┃   - IsCompleted()メソッド（完了判定）※Phase 6追加
┃   - シグナル生成（SIGNAL_BUY/SELL/NONE）
┃  実装状態: ✅ 実装済み
┃
┗━ CDecisionRSI_Simple.mqh
   クラス名: CDecisionRSI_Simple
   役割: RSIベースの売買判断
   機能ID: FUNC_ID_LOGIC_RSI_SIMPLE (310)
   主要機能:
    - RSI閾値判定（買われすぎ/売られすぎ）
    - シグナル生成（BUY/SELL/NONE）
    - Phase 6: 判断結果ログ（LOG_ID 110, 111）
   実装状態: 🟡 部分実装
   不足機能: LOG_ID 110, 111のログ出力実装確認

■ Layer 4: Execution（実行層）
┣━ CExecutionBase.mqh
┃  クラス名: CExecutionBase（基底クラス）
┃  役割: 注文実行の基底クラス
┃  主要機能:
┃   - OrderSend()ラッパー
┃   - OrderModify()ラッパー
┃   - OrderClose()ラッパー
┃   - エラーハンドリング
┃  実装状態: ✅ 実装済み
┃
┗━ CExecutionManager.mqh
   クラス名: CExecutionManager
   役割: 実行要求の処理（PLACE/MODIFY/CANCEL）
   機能ID: FUNC_ID_ORDER_GENERATOR (400)
   主要機能:
    - ProcessRequest()メソッド（要求振り分け）
    - 注文配置（PLACE）
    - 注文変更（MODIFY）
    - 注文取消（CANCEL）
    - Phase 6: 実行結果ログ（LOG_ID 101-103, 108）
   実装状態: 🟡 部分実装
   不足機能: LOG_ID 101-103, 108のログ出力実装確認

■ Layer 5: Strategy（戦略層）
┣━ CStrategy_OCOFollow.mqh
┃  クラス名: CStrategy_OCOFollow
┃  役割: OCO（Buy Stop/Sell Stop）追従戦略
┃  主要機能:
┃   - OCO注文配置
┃   - 未約定注文の価格追従（MODIFY）
┃   - 片側約定時の反対側取消
┃   - スプレッドチェック
┃   - Phase 2-1: ログ状態管理変数（完了）
┃   - Phase 6: 戦略層ログ（LOG_ID 100, 104-107, 109）
┃  実装状態: 🟡 部分実装
┃  不足機能:
┃   - EnterState()メソッド未実装
┃   - GetState()メソッド未実装
┃   - 直接代入（m_state = ...）の修正（9箇所）
┃   - LOG_ID 100, 104-107, 109のログ出力未実装
┃
┗━ CStrategyManager.mqh
   クラス名: CStrategyManager
   役割: アクティブな戦略の管理・呼び出し
   主要機能:
    - Strategy登録（Init）
    - 毎Tick Strategy更新（Update）
    - 完了検知（IsCompleted）
    - Phase 6: COMPLETED後も呼び続ける仕様対応
   実装状態: ✅ 実装済み

■ 外部ライブラリ
┣━ EXMQL.mqh
┃  役割: MQL取引ライブラリ
┃  主要機能: OrderSend/Modify/Close等のラッパー
┃  実装状態: ✅ 実装済み
┃
┗━ errordescription.txt
   役割: エラーコード定義
   主要機能: trade server / runtime error codes
   実装状態: ✅ 実装済み

========================================
2. インクルード依存関係ツリー
========================================

Aegis_Hybrid.mq4 / Aegis_Hybrid.mq5 (エントリーポイント)
└── Aegis_Core.mqh (全体制御)
    ├── CLA/00_Common/CLA_Common.mqh (共通定義)
    ├── CLA/00_Common/CLA_Data.mqh (共有状態管理)
    │   ├── CLA_Common.mqh ← 再利用
    │   └── CFileLogger.mqh (ログ実装)
    │       ├── ILogger.mqh (インターフェース)
    │       ├── CLA_Common.mqh ← 再利用
    │       └── EXMQL/EXMQL.mqh (外部ライブラリ)
    ├── CLA/01_Gatekeeper/CGatekeeper.mqh (安全制御)
    │   ├── CLA_Common.mqh ← 再利用
    │   └── CLA_Data.mqh ← 再利用
    ├── CLA/02_Observation/CObservationPrice.mqh (価格観測)
    │   ├── CObservationBase.mqh (基底クラス)
    │   │   ├── CLA_Common.mqh ← 再利用
    │   │   └── CLA_Data.mqh ← 再利用
    │   ├── CLA_Common.mqh ← 再利用
    │   └── CLA_Data.mqh ← 再利用
    ├── CLA/02_Observation/CObservationRSI.mqh (RSI観測)
    │   ├── CObservationBase.mqh ← 再利用
    │   ├── CLA_Common.mqh ← 再利用
    │   └── CLA_Data.mqh ← 再利用
    ├── CLA/03_Decision/CDecisionRSI_Simple.mqh (RSI判断)
    │   ├── CDecisionBase.mqh (判断基底クラス)
    │   │   ├── CLA_Common.mqh ← 再利用
    │   │   └── CLA_Data.mqh ← 再利用
    │   └── CObservationRSI.mqh ← 再利用
    ├── CLA/04_Execution/CExecutionBase.mqh (実行基底)
    │   ├── CLA_Common.mqh ← 再利用
    │   ├── CLA_Data.mqh ← 再利用
    │   └── EXMQL/EXMQL.mqh ← 再利用
    ├── CLA/04_Execution/CExecutionManager.mqh (実行管理)
    │   ├── CLA_Common.mqh ← 再利用
    │   ├── CLA_Data.mqh ← 再利用
    │   ├── CExecutionBase.mqh ← 再利用
    │   └── EXMQL/EXMQL.mqh ← 再利用
    ├── CLA/05_Strategy/CStrategy_OCOFollow.mqh (OCO戦略)
    │   ├── CLA_Common.mqh ← 再利用
    │   ├── CLA_Data.mqh ← 再利用
    │   └── CDecisionBase.mqh ← 再利用
    └── CLA/05_Strategy/CStrategyManager.mqh (戦略管理)
        ├── CLA_Data.mqh ← 再利用
        └── CDecisionBase.mqh ← 再利用

【依存関係の特徴】
- ✅ 循環依存なし: 全てのレイヤーは下位レイヤーのみに依存
- ✅ 共通定義の再利用: CLA_Common.mqh, CLA_Data.mqhは各所で参照
- ✅ レイヤー境界明確: 上位レイヤーが下位レイヤーを直接参照しない設計

========================================
3. 機能ID（ENUM_FUNCTION_ID）マッピング
========================================

FUNC_ID_NONE         = 0    (未使用)
FUNC_ID_MAIN_CONTROL = 1    (Aegis_Core.mqh)

■ Layer 0: Common (0-99)
FUNC_ID_COMMON_BASE  = 10   (CLA_Common.mqh)
FUNC_ID_CLA_DATA     = 900  (CLA_Data.mqh)

■ Layer 1: Gatekeeper (100-199)
FUNC_ID_GATEKEEPER    = 100 (CGatekeeper.mqh)
FUNC_ID_KILL_SWITCH   = 101 (未実装)
FUNC_ID_HEALTH_MONITOR = 102 (未実装)

■ Layer 2: Observation (200-299)
FUNC_ID_PRICE_OBSERVER   = 200 (CObservationPrice.mqh)
FUNC_ID_TIME_SIGNAL      = 201 (未実装)
FUNC_ID_ECONOMIC_SIGNAL  = 202 (未実装)
FUNC_ID_TECHNICAL_MA     = 203 (未実装)
FUNC_ID_TECHNICAL_MACD   = 204 (未実装)
FUNC_ID_TECHNICAL_RSI    = 205 (CObservationRSI.mqh)
FUNC_ID_TECHNICAL_STOCH  = 206 (未実装)
FUNC_ID_SIGNAL_INTEGRATOR = 210 (未実装)

■ Layer 3: Decision (300-399)
FUNC_ID_ENVIRONMENT_JUDGE  = 300 (未実装)
FUNC_ID_DECISION_EVALUATOR = 301 (未実装)
FUNC_ID_EXTERNAL_CONFIG    = 302 (未実装)
FUNC_ID_HOT_RELOAD         = 303 (未実装)
FUNC_ID_LOGIC_RSI_SIMPLE   = 310 (CDecisionRSI_Simple.mqh)

■ Layer 4: Execution (400-499)
FUNC_ID_ORDER_GENERATOR  = 400 (CExecutionManager.mqh)
FUNC_ID_POSITION_MANAGER = 401 (未実装)
FUNC_ID_TRAILING_MANAGER = 402 (未実装)
FUNC_ID_CLOSE_JUDGE      = 403 (未実装)

■ Layer 5: Logging (500-599)
FUNC_ID_STRUCTURED_LOGGER = 500 (CFileLogger.mqh)

========================================
4. ログID（ENUM_LOG_ID）マッピング
========================================

■ 100番台: 通常状態ログ（Phase 6）
LOG_ID_OCO_PLACE     = 100 (OCO配置成功)
LOG_ID_MODIFY_TRY    = 101 (注文変更試行)
LOG_ID_MODIFY_OK     = 102 (注文変更成功)
LOG_ID_MODIFY_FAIL   = 103 (注文変更失敗)
LOG_ID_NO_CHANGE     = 104 (価格変更不要)
LOG_ID_SPREAD_SKIP   = 105 (スプレッド超過)
LOG_ID_SPREAD_OK     = 106 (スプレッド正常化)
LOG_ID_TRAIL_TRIGGER = 107 (追従トリガー)
LOG_ID_CANCEL_OK     = 108 (注文取消成功)
LOG_ID_FILL_DETECT   = 109 (約定検出)
LOG_ID_RSI_DECISION  = 110 (RSI判断)
LOG_ID_DECISION_SKIP = 111 (判断スキップ)

■ 1000番台: Gatekeeper層（将来拡張用）
LOG_ID_GATEKEEPER    = 1000 (予約)

■ 2000番台: Observation層（将来拡張用）
LOG_ID_OBSERVATION   = 2000 (予約)

■ 3000番台: Execution層（既存）
LOG_ID_EXEC_PLACE    = 3001 (注文配置)
LOG_ID_EXEC_MODIFY   = 3002 (注文修正)
LOG_ID_EXEC_CANCEL   = 3003 (注文取消)
LOG_ID_EXEC_CLOSE    = 3004 (ポジション決済)

■ 4000番台: Decision層（将来拡張用）
LOG_ID_DECISION      = 4000 (予約)

■ 5000番台: Strategy層（将来拡張用）
LOG_ID_STRATEGY      = 5000 (予約)

========================================
5. 実装状態サマリー
========================================

【完全実装】✅
- Aegis_Core.mqh (制御層)
- Aegis_Hybrid.mq4/mq5 (エントリーポイント)
- CLA_Common.mqh (共通定義)
- ILogger.mqh (ログインターフェース)
- CObservationBase.mqh (観測基底)
- CObservationPrice.mqh (価格観測)
- CObservationRSI.mqh (RSI観測)
- CDecisionBase.mqh (判断基底)
- CExecutionBase.mqh (実行基底)
- CStrategyManager.mqh (戦略管理)
- EXMQL.mqh (外部ライブラリ)

【部分実装】🟡
- CLA_Data.mqh (AddLogEx確認必要)
- CFileLogger.mqh (CSV 10カラム対応必要)
- CGatekeeper.mqh (Phase 6ログ確認必要)
- CDecisionRSI_Simple.mqh (ログ出力確認必要)
- CExecutionManager.mqh (ログ出力確認必要)
- CStrategy_OCOFollow.mqh (Phase 2-1完了必要、ログ未実装)

【未実装】❌
- 経済指標観測（CObservationEconomic）
- 環境認識機能（FUNC_ID_ENVIRONMENT_JUDGE）
- ポジション追従戦略（CStrategy_Trailing系）
- パニックログ本実装（CriticalSnapshotLogger）
- スポットログ本実装（SpotLogger）

========================================
6. 次のステップ
========================================

優先度1: Phase 6完了（9日）
 - Task 1: Phase 2-1完了（0.5日）
 - Task 2-8: ログ実装（5.5日）
 - Task 9: 長期テスト（3日）

優先度2: 高優先機能（5日）
 - ポジション追従戦略（3日）
 - 環境認識機能（2日）

優先度3: Phase 7実装（7日）
 - パニックログ（2日）
 - スポットログ（2日）
 - 経済指標観測（3日）

総所要期間: 約4.5週間（22日）

========================================




