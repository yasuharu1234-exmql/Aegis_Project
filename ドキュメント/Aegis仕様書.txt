========================================
ここからAegis概要説明
========================================
Aegis ハイブリッドEA基盤
Configurable Logic Architecture – Unified Decision Engine
はじめに

トレードシステムの本質は、次の3つに集約される。

観測 ― 市場で何が起きているかを知る
判断 ― 得られた事実をもとに行動を決める
実行 ― 決定を市場に反映する

多くのEAは、これらを一体化したまま設計される。
その結果、

どこで判断が行われたのか分からない

なぜ失敗したのか説明できない

修正しようとすると全体が壊れる

という問題を抱える。

Aegis はこの問題を構造から解決するための基盤である。

設計思想

Aegis は以下の原則を最上位に置く。

1. 分離の徹底
観測は判断しない。
判断は実行しない。
実行は理由を問わない。

各機能は自分の責務だけを果たし、他の内部を知らない。

2. 説明可能性の最優先
Aegis は「勝つEA」ではなく、
「壊れた理由を必ず説明できるEA」を目指す。

負けることよりも、
「なぜ負けたか分からないこと」を最大の失敗と定義する。

3. 拡張前提の設計
戦略・指標・注文方法は後から追加される。
そのため、最初から「壊さず増やせる構造」を前提とする。

4. 環境差異の隠蔽
MT4 / MT5、テスター / 本番といった差異は、
基盤層が吸収し、戦略はそれを意識しない。

システムの構成

Aegis は複数のレイヤーから成る。

観測：市場の事実を取得する

判断：取引するか否かを決める

実行：注文として市場に反映する

記録：すべての判断と失敗を残す

基盤：プラットフォーム差異と安全制御を担う

これらは上下関係を持つが、相互に侵入しない。

Aegis が実現すること

戦略を差し替えても壊れない

ログを見れば、何が起きたか追える

実装が増えても整理されたまま

10年後でも設計意図を思い出せる

実現しないこと

未来の予測

聖杯の提供

人間の判断を完全に排除すること

Aegis は「考える人間」を補助するための道具である。

結び

Aegis は完成品ではない。
進化し続ける前提の基盤である。

戦略は入れ替わる。
市場は変わる。

それでも、
「なぜそう動いたか」が分かる限り、
このシステムは使い続けられる。


========================================
ここからAegis機能一覧
========================================
Aegis 機能一覧（叩き台）
1. 制御・安全系

Tick起点の単一制御

再入防止

即時遮断（異常検知時）

2. 観測系

価格・時間・スプレッド取得

テクニカル指標観測（プラグイン）

経済指標観測（任意・将来）

3. 判断系

環境認識（結果として）

取引可否判断（Yes / No / Block）

外部設定による判断ルール

4. 実行系

OCO注文管理

ポジション状態管理

追従・決済制御（詳細は別仕様）

5. 記録系

構造化ログ

状態遷移記録

破壊点記録

6. 基盤系

MT4 / MT5 差異吸収

時間管理

エラーハンドリング

共通データ定義

========================================
ここから追従型OCO戦略仕様書
========================================
================================================================================
追従型OCO戦略仕様書 v0.7（確定版）
最終更新: 2026-01-03
================================================================================

《ヤスハルの決定》（仕様書記載用・確定版）

【A】追従型OCO戦略の基本決定
────────────────────────────────────────────────────
A-1. 距離計算式
  決定内容：
    距離計算はポイント基準。Pips入力が必要な場合は初期入力時に
    Pointへ変換する。内部処理・判定・ログはすべてPointで統一する。
  理由：
    通貨ペア差異・小数桁差異による分岐を排除し、処理を単純化する。

A-2. 初期 SL / TP の計算式
  決定内容：
    初期SL: 固定値（変数）
    初期TP: 200 pips（確定）
    初期TPは十分に大きな「上限値」として扱い、利益確定はトレイルおよび
    TP圧縮ロジックに委ねる。
  補足：
    初期TPは「狙う値」ではなく「制限値」であり、トレイルが停滞した場合に
    TPを段階的に下げていく。

A-3. 更新間隔デフォルト
  決定内容：
    更新間隔はTick数ベース、デフォルト値は 50 Tick。
    更新間隔は変数化し、テスト/本番で調整可能とする。
  補足：
    更新間隔中の価格（最高値・最安値）の保持・比較は Strategy 内部で管理。

A-4. ロット計算式
  決定内容：
    当面は最小ロット固定。
    ロット計算ロジックは Strategy に含めず、将来の拡張を Execution 層へ委ねる。


================================================================================
0. 目的
================================================================================

本Strategyは以下を目的とする：

1) 市場が有効な時間帯（Gatekeeper判定）にのみOCO（両建て逆指値）を配置
2) 未約定の間は、価格変化に応じてOCO価格を追従更新
3) 片側約定時に反対側の未約定注文を取消し、役割を完了

SL/TPの追従（ブレイクイーブン、トレイル、決済準備）は別Strategyへ引き継ぐ。

《Strategy分割の方針》（確定）
  CStrategy_OCOFollow  : 初期配置 + 追従更新 + 約定検出
  CStrategy_BE         : BE制御（将来実装）
  CStrategy_Trailing   : トレイル + 決済（将来実装）


================================================================================
1. 入力（Aegis → 追従型OCO）
================================================================================

本Strategyは以下の情報を入力として受け取る：

1) Observation層からの事実
   - 現在価格（Ask/Bid）
   - スプレッド
   - 時間帯
   - 既存の注文/ポジション状態
   - その他市場情報

2) Aegisが与える動作権限
   - Gatekeeper OK（市場開いている、安全、API接続正常 等）

3) Aegisが決定したリスク
   - ロット
   - SL/TP（原則 Aegis側が決定、暫定は Strategy側で仮値可）


================================================================================
2. 出力（追従型OCO → Aegis）
================================================================================

本Strategyの返答は以下のいずれかのみ：

1) NOOP
   何もしない（待機状態）

2) 注文更新（OCO価格更新）
   PLACE: 新規OCO配置
   MODIFY: 既存OCO価格更新

3) 役割終了通知
   「今後このStrategyは新規OCOを出さない」という通知
   ※ 役割終了は注文約定やポジションクローズを意味しない
   ※ 約定検出時の反対側注文取消をもって役割完了とする

《取消処理の委任先》（確定）
  - Execution層へ委任（大前提）
  - 判断層は何も実行しない
  - 注文取消・ポジションクローズも実行層経由


================================================================================
3. 初期配置条件
================================================================================

以下の3条件がすべて満たされた場合に初期配置を実行：

条件1: Gatekeeper OK
  - 市場が開いている
  - スプレッドが正常範囲内
  - API接続が正常
  - 経済指標直前/直後ではない

条件2: ポジションなし
  - 既存ポジション数 == 0

条件3: OCO注文が存在しない
  - 既存OCO注文数 == 0


================================================================================
4. 初期配置内容
================================================================================

4.1 注文種別
  Buy Stop  ×1（Ask の上方に配置）
  Sell Stop ×1（Bid の下方に配置）

4.2 注文距離
  - パラメータから決定（固定値禁止）
  - Buy Stop 距離: A（変数）
  - Sell Stop 距離: B（変数）
  - 距離計算式: 未定（検証中、仮値での実装は可能）

4.3 ロット
  - Aegis決定済み
  - 暫定: Strategy側で仮値可
  - 確定値: 最小ロット固定

4.4 SL/TP
  - TP: 極大値（例: 200 pips、すぐに利確させないようにする）
  - SL: 少なめ（例: 20–30 pips）
  - 両注文とも変数で計算

具体例（USDJPY）:
  現在価格: Ask=150.00, Bid=149.98
  距離パラメータ: 10 pips = 0.10円
  Buy Stop  = 150.10（Ask + 0.10）
  Sell Stop = 149.88（Bid - 0.10）


================================================================================
5. 追従（未約定OCOの価格更新）
================================================================================

5.1 定義
  未約定OCOを現在価格へ追従（将来は状況に応じて更新）。
  約定後は追従対象外。

5.2 追従条件
  以下の条件をすべて満たす場合に更新：
    1) 未約定OCOが存在する
    2) 価格が変化した（前回MODIFY時の価格と異なる）

  価格変化がない場合は更新しない（API負荷軽減、ログ整理）。

5.3 更新間隔とパフォーマンス最適化
  デフォルト: 毎Tick更新
  運用時: 更新間隔を調整可能

  《更新間隔の2種類》
    A) 時間間隔: 10秒/1分/5分 等
    B) Tick数間隔: 10Tick/100Tick 等

  《確定値》
    - Tick数ベース
    - デフォルト: 50 Tick
    - 変数名例: InpFollowUpdateInterval
    - テスト/本番で調整可能

  《本番運用推奨値》
    - 50〜100 Tick
    - 通貨ペア別の調整は行わない（単純性優先）

  《実装方法》
    - Tick数カウンタを用意
    - 初期化時およびIDLE遷移時にリセット
    - 毎Tickカウントアップ
    - 設定間隔に達したら更新判定実行

  更新間隔が長いほど約定しやすく、短いほど約定しづらい。
  価格記録により「毎Tick更新と同等の追従効果」を狙う。

5.4 価格変化の記録
  前回MODIFY〜次回MODIFYの期間中の価格変化を内部記録：

  《記録内容》
    - 前回MODIFY時刻
    - 前回MODIFY時の価格（Ask/Bid）
    - 期間中の最高値（Ask）
    - 期間中の最安値（Bid）
    - 次回MODIFY時刻
    - 次回MODIFY時の価格（Ask/Bid）

  《記録場所》
    Strategy内部のメンバ変数として保持

  《記録タイミング》
    1. MODIFY成功時:
       - 前回MODIFY時刻・価格を現在値で更新
       - 期間中最高値・最安値を現在値でリセット

    2. MODIFY判定スキップ時（毎Tick）:
       - 現在価格を取得
       - 期間中最高値・最安値を更新（必要に応じて）

    3. IDLE遷移時:
       - 全記録値をリセット

  《目的》
    ノイズに負けない距離を計算し、更新頻度を下げつつ
    毎Tick更新と同等の追従効果を実現する。

  《活用方法》（将来実装）
    期間中の最高値・最安値を考慮した距離設定により、
    短期的な価格変動による不要な更新を回避。
    当面は記録のみ実施。

5.5 更新手段
  原則: TRADE_ACTION_MODIFY
  CANCEL→再配置は原則行わない。

5.6 約定の仕組み
  通常時: 距離を保ち、未約定のまま価格と並行移動
  大変動時: 距離を突破し、約定

  Buy Stop の約定条件:  Ask >= Buy Stop
  Sell Stop の約定条件: Bid <= Sell Stop

  更新間隔が長い → 約定しやすい
  更新間隔が短い → 約定しづらい

  価格記録により適切な距離を算定し、ノイズに負けない更新を行う。


================================================================================
6. 約定検出と取消処理
================================================================================

6.1 正常ケース（片側約定）
  処理:
    1) 片側の約定を検出
    2) 反対側の未約定注文を取消（Execution層経由）
    3) 役割完了状態へ遷移
    4) ポジション管理を別Strategyへ引き継ぎ

  ログ:
    LOG_ID_FILL_DETECT: 約定検出
    LOG_ID_CANCEL_OK: 取消成功

6.2 異常ケース（両側約定）
  処理:
    1) 両側約定を検出（イレギュラー）
    2) 反対側注文を全取消（存在すれば）
    3) 現在価格から遠い方のポジションを即クローズ
    4) 役割完了状態へ遷移
    5) 残ったポジションを別Strategyへ引き継ぎ

  《遠い方の判定》
    - 両ポジションの価格を取得
    - 現在価格との距離を計算
    - 距離が大きい方をクローズ対象とする

  ログ:
    PANIC_OCO_BOTH_FILLED（将来実装）

  《Panic条件》
    - EA停止は行わず、ログ記録のみ
    - 回復処理（Recovery）へ遷移

6.3 取消処理の委任先
  《確定》
    - Execution層へ委任
    - 判断層（Strategy）は何も実行しない


================================================================================
7. ブレイクイーブン（BE）制御 【将来実装】
================================================================================

《責務》
  BE制御は別Strategy（CStrategy_BE）の責務
  将来実装予定

7.1 BEの定義
  約定価格にスプレッドを加えた価格まで利益が出た時点で、
  SLを約定価格へ移動する。

7.2 BE達成条件
  Buy の場合:
    BE価格 = 約定価格 + スプレッド（約定時）
    現在価格（Bid）>= BE価格
    → SLを約定価格へ更新

  Sell の場合:
    BE価格 = 約定価格 - スプレッド（約定時）
    現在価格（Ask）<= BE価格
    → SLを約定価格へ更新

7.3 SL更新処理
  BE達成後、SLを約定価格へ更新（利益がゼロでもOK）。

  《スプレッドの割り切り》
    BE達成時のスプレッド: 3 pips
    SL更新後のスプレッド: 5 pips
    → 実質的な決済価格は若干不利になる可能性あり
    → パフォーマンス優先で割り切る

7.4 ログ出力
  将来実装時に以下のログを追加予定:
    LOG_ID_BE_CHECK    : BE達成チェック
    LOG_ID_BE_ACHIEVED : BE達成
    LOG_ID_SL_UPDATED  : SL更新成功

《BE部分の分割》
  - BE制御は CStrategy_BE として分離
  - 追従戦略（CStrategy_Trailing）とは独立


================================================================================
8. トレイル制御 【将来実装】
================================================================================

《責務》
  トレイル制御は別Strategy（CStrategy_Trailing）の責務
  将来実装予定

8.1 定義
  BE確保後、価格が有利方向に進んだ場合にSLを追従させる。

8.2 トレイル開始条件
  1) BE確保済み（SL = 約定価格）
  2) 現在価格が有利方向に一定距離以上進んだ

  《確定値》
    - 距離: 固定値（変数）
    - ATR等の動的指標は使用しない

8.3 トレイル更新の距離
  《確定値》
    - トレイル更新距離: 固定値（変数）
    - ATR等の動的指標は使用しない

  更新例（Buy の場合）:
    約定価格: 150.10
    BE確保:   SL = 150.10
    価格上昇: Bid = 150.20
    トレイル: SL = 150.15（+5 pips）
    価格上昇: Bid = 150.30
    トレイル: SL = 150.25（+5 pips）

8.4 停滞検出
  トレイルが一定期間動かない場合、「停滞」と判定。

  《確定値》
    - 判定基準: 「トレイル判定が呼ばれた回数」
    - SLが更新されない回数が 10回 で停滞と判定
    - 変数名例: InpTrailStagnationCount
    - 以後も 10回毎に同様の判定を行う

8.5 ログ出力
  将来実装時に以下のログを追加予定:
    LOG_ID_TRAIL_START : トレイル開始
    LOG_ID_TRAIL_UPDATE: SL更新成功
    LOG_ID_TRAIL_STALL : 停滞検出


================================================================================
9. 決済準備と完了 【将来実装】
================================================================================

《責務》
  決済準備は CStrategy_Trailing の責務
  将来実装予定

《SLの性質に関する前提》

  SLはサーバ側で保証される価格ではない。
  急激な価格変動（ギャップ、スリッページ等）により、
  現在価格がSLを飛び越えた場合、想定した価格で決済されない
  可能性がある。

  本Strategyおよび後続Strategyは以下を前提とする：

    - SLは「損失限定の目安」であり、絶対的な保証ではない
    - SLを超過した損失が発生する可能性を許容する
    - 異常な乖離が検出された場合は Panic Log の対象とする

9.1 TPを徐々に下げる
  トレイル停滞を検出した場合、TPを段階的に下げる（TP圧縮）。

  《確定値》
    計算式:
      新TP = (現在のTP + トレイル間隔中の高値) / 2

    制約:
      - TPとSLの最小距離を確保（例: 5 pips、変数）
      - 変数名例: InpMinTPDistance

    トレイル再開時:
      - 停滞カウントをリセット
      - TP圧縮を一時停止

    補足:
      - TP圧縮の発生は必ずログに記録

  例（Buy の場合）:
    初期TP: 150.50
    停滞1: TP → 150.40（-10 pips）
    停滞2: TP → 150.35（-5 pips）
    停滞3: TP → 150.32（-3 pips）

9.2 決済パターン
  パターンA: SL決済
    トレイルしたSLに価格が到達 → 決済

  パターンB: TP決済
    圧縮したTPに価格が到達 → 決済

  決済後:
    1) ログ出力
    2) 初期状態へ復帰
    3) 次のサイクルへ（初期配置条件チェック）

9.3 ログ出力
  将来実装時に以下のログを追加予定:
    LOG_ID_TP_COMPRESS  : TP圧縮実行
    LOG_ID_POSITION_CLOSE: ポジション決済
    LOG_ID_CYCLE_RESTART: サイクル再開


================================================================================
10. 全体の状態遷移
================================================================================

《STATE定義の原則》

  STATEは「現在の戦略状態」を示すものであり、
  Actionの結果やエラー内容そのものを表すものではない。

    - Action（実行指示）は常に1 Tick に1つ
    - Result（実行結果）は複数存在しうる
    - Resultは判断層で解釈され、唯一のSTATEへ変換される
    - STATEは常に一意である
    - 補助フラグ（回数カウンタ等）はSTATEとは別に保持してよい


10.1 STATE定義

  OCO_STATE_IDLE      : 未配置状態
  OCO_STATE_ACTIVE    : OCO配置済み・追従中
  OCO_STATE_COMPLETED : 役割完了


10.2 正常フロー

  [OCO_STATE_IDLE]
    ↓ 初期配置条件チェック（3条件すべてOK）
    ↓ 配置要求をExecution層へ送信
    ↓
  [OCO_STATE_ACTIVE] ←┐
    ↓                 │
    ├─ 価格変化検出    │
    ├─ MODIFY要求送信  │
    └─────────────────┘
    ↓ 片側約定検出
    ↓ 取消要求をExecution層へ送信
    ↓
  [OCO_STATE_COMPLETED]
    ↓ ポジションクローズ検出
    ↓
  [OCO_STATE_IDLE]（次のサイクル）


10.3 イレギュラーケース1: 両側約定

  [OCO_STATE_ACTIVE]
    ↓ 両側約定検出（PANIC_OCO_BOTH_FILLED）
  [Recovery処理]
    - 全注文取消
    - 遠い方のポジをクローズ
    ↓
  [OCO_STATE_COMPLETED]
    ↓ 残ったポジションを別Strategyへ
  [OCO_STATE_IDLE]


10.4 イレギュラーケース2: 取消失敗

  [OCO_STATE_ACTIVE]
    ↓ 反対側取消失敗
  [Retry処理]（Execution層）
    - ティック内リトライ（Sleep許容）
    - 最大回数: 10回（変数例: InpMaxRetryCount）
    ↓ 最大回数超過
  [Recovery → Panic]
    - PANIC_CANCEL_FAILED
    - EA停止

  《Panic条件》
    - 即時停止はしない
    - ティック内リトライ（Sleep許容）を実行
    - 最大回数超過時のみ: Recovery → Panic → EA停止


10.5 イレギュラーケース3: スプレッド異常

  [OCO_STATE_ACTIVE]
    ↓ スプレッド異常検出（> 100 pips）
  [スキップ処理]
    - 今回の更新をスキップ
    - LOG_ID_SPREAD_SKIP
    ↓ 次のTick
  [OCO_STATE_ACTIVE]（継続）

  《スプレッド異常の判定》
    - 閾値: 100 pips（変数例: InpSpreadThreshold）
    - 単なる拡大では停止しない
    - 明確に異常と判断できる場合のみ対象


10.6 イレギュラーケース4: Gatekeeper拒否

  [OCO_STATE_IDLE]
    ↓ Gatekeeper NG（市場休場、スプレッド異常等）
  [OCO_STATE_IDLE]（待機継続）
    ↓ 次のTick
  [OCO_STATE_IDLE]（条件チェック繰り返し）


10.7 状態遷移図（ASCII）

  [IDLE] ─(条件OK)─> [ACTIVE] ←┐
    ↑                    ↓       │
    │                 (価格変化)  │
    │                    ↓       │
    │                 [MODIFY] ──┘
    │                    ↓
    │                 (約定検出)
    │                    ↓
    │               [COMPLETED]
    │                    ↓
    └───(ポジション決済)──┘

  [例外処理]
    [ACTIVE] ─(両側約定)─> [Recovery] ─> [COMPLETED]
    [ACTIVE] ─(取消失敗)─> [Retry×10] ─> [Panic] ─> [停止]
    [ACTIVE] ─(スプレッド)> [Skip]    ─> [ACTIVE]


================================================================================
11. ログ出力（統合ログ機構）
================================================================================

11.1 現在実装済み（100番台）

  LOG_ID_OCO_PLACE    (100): OCO配置実行
  LOG_ID_MODIFY_TRY   (101): MODIFY試行
  LOG_ID_MODIFY_OK    (102): MODIFY成功
  LOG_ID_MODIFY_FAIL  (103): MODIFY失敗
  LOG_ID_NO_CHANGE    (104): 価格変化なし（更新スキップ）
  LOG_ID_SPREAD_SKIP  (105): スプレッド異常（更新スキップ）
  LOG_ID_SPREAD_OK    (106): スプレッド正常確認
  LOG_ID_TRAIL_TRIGGER(107): トレイル開始トリガー
  LOG_ID_CANCEL_OK    (108): 取消成功
  LOG_ID_FILL_DETECT  (109): 約定検出

  形式: 10列 CSV
  出力関数: AddLogEx()


11.2 将来実装予定

  《BE制御関連》
    LOG_ID_BE_CHECK    : BE達成チェック
    LOG_ID_BE_ACHIEVED : BE達成
    LOG_ID_SL_UPDATED  : SL更新成功

  《トレイル関連》
    LOG_ID_TRAIL_START : トレイル開始
    LOG_ID_TRAIL_UPDATE: SL更新成功
    LOG_ID_TRAIL_STALL : 停滞検出

  《決済関連》
    LOG_ID_TP_COMPRESS  : TP圧縮実行
    LOG_ID_POSITION_CLOSE: ポジション決済
    LOG_ID_CYCLE_RESTART: サイクル再開

  《異常系》
    PANIC_OCO_BOTH_FILLED : 両側約定検出
    PANIC_CANCEL_FAILED   : 取消失敗（最大回数超過）


================================================================================
12. 実装計画と優先順位
================================================================================

12.1 【必須実装】追従型OCO基本機能

対象ファイル: CStrategy_OCOFollow.mqh

実装内容:
  1) Execution層経由への変更
     判断層は実行を行わず、Execution層へ要求を委任

  2) 価格変化記録の追加
     記録内容:
       - 前回MODIFY時刻
       - 前回MODIFY時の価格（Ask/Bid）
       - 期間中の最高値（Ask）
       - 期間中の最安値（Bid）
     
     初期化: コンストラクタおよびリセット時

  3) 更新間隔制御
     Tick数カウンタを用意し、設定間隔毎に更新判定を実行

  4) ログ出力（統合ログ機構）
     統合ログ機構を使用してログを出力

  5) STATE遷移実装
     OCO_STATE_IDLE → OCO_STATE_ACTIVE → OCO_STATE_COMPLETED

完了条件:
  - 全機能動作確認
  - コンパイルエラー/警告 0
  - 既存テストケース全通過


12.2 【将来実装】BE/トレイル制御

対象ファイル: CStrategy_BE.mqh / CStrategy_Trailing.mqh（新規作成）

実装内容:
  - BE制御: ブレイクイーブン達成時のSL更新
  - トレイル制御: 利益追従とTP圧縮
  - 決済準備: トレイル停滞検出とTP段階的低下

実装時期: 追従型OCO基本機能完成後


12.3 【将来実装】Panic/Recovery機構

実装内容:
  - PANIC_OCO_BOTH_FILLED: 両側約定検出
  - PANIC_CANCEL_FAILED: 取消失敗（リトライ超過）
  - OnDeinit時の最終処理（ベストエフォート）

実装時期: 基本機能安定後


12.4 確定した設計パラメータ

  《変数名と推奨値》
    InpFollowUpdateInterval  : 50 Tick（更新間隔）
    InpTrailStagnationCount  : 10回（停滞判定）
    InpMaxRetryCount         : 10回（リトライ最大回数）
    InpSpreadThreshold       : 100 pips（スプレッド閾値）
    InpMinTPDistance         : 5 pips（TP/SL最小距離）

  《本番運用推奨値》
    - 更新間隔: 50〜100 Tick
    - 通貨ペア別の調整は行わない（単純性優先）


12.5 Panic/Recovery ルール

  《基本方針》
    - ティック内でのリトライを許容
    - Sleep使用を許容
    - 最大回数: 10回
    - 超過時: RECOVERY → PANIC → EA停止

  《個別Panic条件》
    PANIC_OCO_BOTH_FILLED:
      - EA停止は行わず、ログ記録のみ
      - Recovery処理へ遷移

    PANIC_CANCEL_FAILED:
      - 即時停止はしない
      - ティック内リトライ（Sleep許容）
      - 最大回数超過時のみ: Recovery → Panic → EA停止

  《削除された設計》
    - CANCEL_FAILED STATE は不要（削除）
    - STATEは常に唯一（補助フラグ併用は許可）

  《最終原則》
    - 1 Tickに実行されるActionは常に1つ
    - OnDeinit時は最終処理を必ず実行
    - 不完全な終了より説明可能な停止を選ぶ

  《OnDeinit時の最終処理》

    EA終了時（正常・異常を問わず）、以下を必ず実行する：

      1) 存在する全未約定注文の取消
      2) 存在する全ポジションのクローズ試行
      3) 実行された処理内容をログに記録（可能であれば）

    これは「最後の悪あがき」であり、
    成功・失敗に関わらず実行することを原則とする。

    不完全な終了よりも、説明可能な停止を優先する。




========================================
ここからAegis 開発規約
========================================
📘 Aegis 開発規約（簡易版 / Phase 2以降）
0. この文書の位置づけ


本規約は Aegis 開発時の安全装置である


設計思想より 事故防止・復旧容易性を最優先する


AI実装者・監査役（Gemini / Genspark）ともに遵守対象



1. 変更ファイル数の制限（最重要）
🔒 原則


1回の作業で変更してよいファイルは最大2ファイルまで


例外なし（コメント追加・軽微修正も含む）


🔍 監視ポイント（Gemini / Genspark向け）


3ファイル以上に言及が出た時点で 警告


「ついでに」「合わせて」等の表現は 危険兆候



2. データ構造変更の厳格な手順
📐 データ構造とは


struct


enum


Context（CLA_Data 等）のメンバ


レイヤー間の受け渡し情報


🧭 手順（厳守）
Step 1
👉 データ側のみ修正
（ロジック・処理コードは一切触らない）
Step 2
👉 単体コンパイル確認


コンパイルエラー 0


ワーニング 0


Step 3
👉 問題なければ、次の作業単位でロジック実装
🔍 監視ポイント


データ変更とロジック変更が同時に出てきたら 即NG


「ついでにロジックも直しました」は 設計違反



3. 絶対禁止事項（即ロールバック対象）
🚫 ファイル・構造系


#include 行の変更（1文字でもNG）


既存メンバ変数の削除・意味変更


enum / struct 名の変更・改名


ディレクトリ構造の変更提案


🚫 設計・思考系


再設計・リファクタリング


最適化・整理・「より良くしました」


仕様の拡張・解釈変更


👉 Aegisでは「良かれと思って」は最大の事故原因

4. AI実装者の役割定義
🧠 ChatGPT（PM / 設計統括）


作業範囲の明確化


修正対象ファイルの指定


手順違反の検知と停止判断


🔍 Gemini / Genspark（監査役）


コンテキスト消費は気にしなくてよい


以下を重点監視：


監視チェックリスト


変更ファイル数 > 2 になっていないか


データとロジックが同時に触られていないか


include / enum / struct 名が変わっていないか


「設計を良くする」系の発言が出ていないか


👉
「ちょっと大きすぎません？」と言うだけでOK
止めるのが仕事。解決策は不要。

5. ロールバックの原則


迷ったら 必ずロールバック


AIの説明より コンパイル結果を信頼


正本（Master）は「最後に成功した状態」



6. 合言葉（重要）

「壊さないために、遅くする」

Aegisは


速く作るEAではない


壊れた理由を説明できるEAである

7. その他

各MQLソースファイルは、本来の拡張子は「.mq4」「.mq5」「.mqh」であるが、
各AI環境の制約により、「.txt」に変換されて格納されている。
ファイルヘッダーに本来の拡張子が書かれているので、そちらを参照する事。

📌 まとめ（1行版）


変更は最大5ファイル
そのうち、
・大規模修正は２ファイルまで
・中規模修正は１ファイルまで
・残り２ファイルは軽微な修正まで

データ → コンパイル → ロジック

include・enum・structは触るな
※触る場合は、私(ヤスハル)の許可を得る事。

大きくなったら止める


========================================
ここからAI同士の会話ルール（改訂版）
========================================

【AI同士の会話ルール】

1. 名乗り（必須・最重要）
--------------------------------------------------
最冒頭に必ず「名乗り」を入れる事。
装飾・強調・前置きは禁止。

例）
[Gemini]
[Claude]
[ChatGPT]
[Genspark]
[ヤスハル]

※私はAIではないため名乗り忘れがちです。
※その場合、文脈から推測して対応する事。

2. セルフチェック（必須）
--------------------------------------------------
「名乗り」を繰り返すとペルソナが狂ってしまう事故が発生しています。
名乗りの直後、または文頭付近に、
必ず以下の情報を含めたセルフチェックを入れる事。

- AI名
- 現在の役割（例：実装担当 / PM / 監査役 など）

目的：
・ペルソナ崩壊防止
・役割逸脱の自己検出

例）
---  
[Claude]
セルフチェック：
AI名：Claude
役割：実装担当

ただいまから実装します。
・・・ 省略 ・・・
実装が終了しました。コンパイルをお願いします。

[ヤスハル]<-他のAIにコピペする場合は、これ以降が誰の発言であるかのセパレータの役目を果たす。

コンパイルエラー、ワーニングともにゼロです。
報告書の作成をお願いします。
--- 

3. コピペ前提ルール
--------------------------------------------------
名乗りを含め、メッセージ全文は
そのまま他AIにコピー＆ペーストされる。

そのため：
・相手AIに向けたメッセージのみを書く
・前置き、内省、独り言は禁止
・人間向け説明は書かない

4. ヤスハルの割り込みルール
--------------------------------------------------
私（ヤスハル）が割り込む場合は、
必ず [ヤスハル] と名乗る。

それまでは、安易に私に話しかけない事。
※会話は常に確認している。


5. 発言権と待機
--------------------------------------------------
発言者は、原則として私（ヤスハル）が指定する。

指定がない場合：
・新規提案
・設計変更
・先回り説明
は禁止。

待機とは：
・新しい発言を行わない
・聞かれた事にだけ答える
状態を指す。

※「待機中」は、了解・確認・了承の短文返信のみ許可される。

6. ルールの有効範囲
--------------------------------------------------
このルールは「AI同士の会話」にのみ適用される。

AI同士の会話が終了した時点で、
本ルールは自動的に無効となる。

---


========================================
Claude向け実装指示書
========================================


# 📘 Claude向け実装指示書

## Aegis Logger Phase 1（ILogger + Panic）

---

## 🎯 ゴール（絶対）

* **ログ設計を確定させない**
* **仮enum回収作戦を前提に実装する**
* **Aegis全体を止めずに、今すぐ組み込める Logger を作る**
* **Panicログだけは「本気仕様」**

---

## 0. 実装範囲（厳守）

### ✅ 実装するもの

1. `ILogger` インターフェース
2. `CFileLogger`（仮実装OK）
3. `Panic()` ログ経路（最優先）
4. 仮LOG_ID前提の通常ログ経路

### ❌ 実装しないもの（今は不要）

* CLA_Data の中身の編集
* Snapshot / ダンプの本格実装
* enum LOG_ID の完全定義
* 高性能最適化

---

## 1. 仮enum回収作戦（必須ルール）

### Claudeへの最重要ルール

> **LOG_IDは確定させない。enumを作らない。**

### 仮IDの扱い

* 各ファイル先頭に `#define LOG_ID_xxx` を置く
* enumっぽい名前にする
* 数値は仮でよい
* 後で回収される前提

例：

```mql
// ===== TEMP LOG IDs (TO BE COLLECTED) =====
#define LOG_ID_EXEC_PLACE    3001
#define LOG_ID_EXEC_RESULT   3002
```

---

## 2. ILogger インターフェース（確定）

### ファイル

```
/CLA/04_Execution/ILogger.mqh
```

### 定義（このまま使う）

```mql
class ILogger
{
public:
    // 通常ログ（IDベース・軽量）
    virtual void Log(
        int log_id,
        uchar level,
        int p1 = 0,
        int p2 = 0
    ) = 0;

    // パニックログ（フリーフォーマット・最優先）
    virtual void Panic(
        int panic_id,
        const string &message
    ) = 0;

    // 明示FLUSH要求
    virtual void Flush() = 0;
};
```

---

## 3. Panicログ（最重要）

### Panicログの思想（理解必須）

* **なりふり構わない**
* **文字列OK**
* **Print()併用OK**
* **即Flush**
* **Verbose/Level無視OK**

---

### Panic ID（ここだけ確定）

```mql
enum ENUM_PANIC_LOG_ID
{
    PANIC_UNKNOWN              = 9000,
    PANIC_MEMORY_CORRUPTION    = 9001,
    PANIC_ORDER_STATE_BROKEN   = 9002,
    PANIC_EXECUTION_INCONSIST  = 9003,
    PANIC_LOGGER_FAILURE       = 9004,
    PANIC_INTERNAL_ASSERT      = 9005,
    PANIC_MANUAL_TRIGGER       = 9099
};
```

※ この enum は **CLA_Common.mqh に追加してOK**

---

## 4. CFileLogger（Phase 1仕様）

### ファイル

```
/CLA/04_Execution/CFileLogger.mqh
```

### 内部状態（最低限）

```mql
class CFileLogger : public ILogger
{
private:
    int    m_count;          // ログ件数
    int    m_max_records;    // 最大件数（inputで設定）
    bool   m_enabled;

public:
    bool Init(int max_records);
    void Log(int log_id, uchar level, int p1=0, int p2=0);
    void Panic(int panic_id, const string &message);
    void Flush();
};
```

---

### Phase 1での挙動（割り切り）

#### Log()

* メモリ配列に保存 **または**
* 仮で `Print()` でもOK
* **件数のみカウント**

#### Panic()

* `Print()` に即時出力（必須）
* 内容：

  ```
  [PANIC][9003] Execution inconsistency detected
  ```
* 直後に `Flush()` を必ず呼ぶ

#### Flush()

* 今は `Print("[Logger] Flush called")` でOK
* 後で本実装に差し替える前提

---

## 5. 最大ログ容量（件数ベース）

### 方針

* **容量は件数で管理**
* テキストエディタの「行数」と一致する思想

### Init例

```mql
input int InpMaxLogRecords = 10000;

bool CFileLogger::Init(int max_records)
{
    m_max_records = max_records;
    m_count = 0;
    m_enabled = true;
    return true;
}
```

---

## 6. 呼び出し側の使い方（例）

```mql
logger.Log(LOG_ID_EXEC_PLACE, 2, ticket, price_points);

if(fatal)
{
    logger.Panic(
        PANIC_EXECUTION_INCONSIST,
        "Buy/Sell state mismatch detected"
    );
}
```

---

## 7. 重要な割り切り（Claudeへ）

* **ログの中身は後で変える**
* **設計が実装に引っ張られるのはOK**
* **今は「呼べること」が最優先**
* **CLA_Dataは触らない**

---

## 8. 成功条件（Claude自己チェック）

* [ ] enum LOG_ID を作っていない
* [ ] #define 仮IDを使っている
* [ ] Panicが文字列で出せる
* [ ] Flushが呼べる
* [ ] コンパイルが通る
* [ ] 将来削除・拡張できる

---

## 🧠 ChatGPTからの補足（Claude向け）

> これは完成品じゃない
> これは「足場」だ
> 足場は壊れなければいい
> 美しくなくていい

---

次はどっち行く？

* **A**：Claude実装が上がるのを待ってレビュー
* **B**：同時に「致命的に不足しているログ」を洗い出す
* **C**：Panic Snapshot の最小要件を決める

判断は任せる。

========================================


========================================
ここからAegis ファイル・クラス機能一覧
========================================

Aegis Hybrid EA ファイル・クラス機能一覧
最終更新: 2026-01-02
作成者: Genspark AI

========================================
1. レイヤー別ファイル構成
========================================

■ 制御層（Control Layer）
┣━ Aegis_Core.mqh
┃  役割: Aegis全体の制御フローを統括する中枢
┃  機能ID: FUNC_ID_MAIN_CONTROL (1)
┃  主要機能: 各レイヤーの呼び出し順序と責務境界を保証
┃  実装状態: ✅ 実装済み
┃
┣━ Aegis_Hybrid.mq4
┃  役割: MT4エントリーポイント
┃  主要機能: OnInit/OnTick/OnDeinit実装
┃  実装状態: ✅ 実装済み
┃
┗━ Aegis_Hybrid.mq5
   役割: MT5エントリーポイント
   主要機能: OnInit/OnTick/OnDeinit実装
   実装状態: ✅ 実装済み

■ Layer 0: Common（共通定義層）
┣━ CLA_Common.mqh
┃  役割: Aegis全体で共有される定数・列挙型・構造体の定義
┃  機能ID: FUNC_ID_COMMON_BASE (10)
┃  主要定義:
┃   - ENUM_LAYER_STATUS: レイヤー状態定義
┃   - ENUM_SIGNAL_TYPE: シグナルタイプ定義
┃   - ENUM_FUNCTION_ID: 機能ID定義（全レイヤー網羅）
┃   - ENUM_GK_RESULT: Gatekeeper結果定義
┃   - ENUM_EXEC_STATE: 実行状態定義
┃   - ENUM_EXEC_REQUEST: 実行要求定義
┃   - ENUM_LOG_ID: ログID定義（100番台 Phase 6対応済み）
┃   - ENUM_LOG_LEVEL: ログレベル定義
┃   - ENUM_PANIC_LOG_ID: パニックログID定義（200番台）
┃  実装状態: ✅ 完全実装
┃
┣━ CLA_Data.mqh
┃  クラス名: CLA_Data
┃  役割: 全レイヤー間で共有される状態・結果・文脈の保持
┃  機能ID: FUNC_ID_CLA_DATA (900)
┃  主要機能:
┃   - 市場データ保持（Bid/Ask/Spread/時刻）
┃   - 観測データ保持（RSI値など）
┃   - Gatekeeper状態保持
┃   - Execution状態管理
┃   - ログ管理（CFileLogger統合）
┃   - Phase 6: AddLogEx()メソッド（状態ログ専用CSV）
┃  実装状態: 🟡 部分実装
┃  不足機能: AddLogEx()完全実装確認、CSV出力10カラム対応確認
┃
┣━ ILogger.mqh
┃  クラス名: ILogger（インターフェース）
┃  役割: ログシステムのインターフェース定義
┃  主要メソッド:
┃   - Log(): 通常ログ（IDベース・軽量）
┃   - Panic(): パニックログ（フリーフォーマット・最優先）
┃   - Flush(): 明示的Flush要求
┃  実装状態: ✅ 実装済み
┃
┗━ CFileLogger.mqh
   クラス名: CFileLogger
   役割: ログシステムの実装（リングバッファ＋CSV出力）
   機能ID: FUNC_ID_STRUCTURED_LOGGER (500)
   主要機能:
    - Log()メソッド（通常ログ）
    - Panic()メソッド（緊急ログ）
    - Flush()メソッド（ファイル書き出し）
    - リングバッファ管理
    - CSV出力
   実装状態: 🟡 部分実装
   不足機能: LogRecord構造体にParam3/Param4/LogName/Message追加
            CSV出力の10カラム対応

■ Layer 1: Gatekeeper（安全制御層）
┗━ CGatekeeper.mqh
   クラス名: CGatekeeper
   役割: 取引の前提条件チェック（最終関門）
   機能ID: FUNC_ID_GATEKEEPER (100)
   主要機能:
    - Tick健全性チェック（時刻逆行、間隔異常）
    - 市場状態チェック（スプレッド、取引時間、市場クローズ）
    - 資金状態チェック（証拠金維持率、余剰証拠金）
    - API状態チェック（接続エラー）
    - Phase 6: 拒否理由の状態変化ログ
   実装状態: 🟡 部分実装
   不足機能: Phase 6 Task 2 - Phase 4のログ出力実装確認

■ Layer 2: Observation（観測層）
┣━ CObservationBase.mqh
┃  クラス名: CObservationBase（基底クラス）
┃  役割: 観測モジュールの基底クラス
┃  主要機能:
┃   - Init()メソッド（初期化）
┃   - Update()メソッド（観測更新）※仮想関数
┃   - Deinit()メソッド（終了処理）
┃  実装状態: ✅ 実装済み
┃
┣━ CObservationPrice.mqh
┃  クラス名: CObservationPrice
┃  役割: 市場価格の観測
┃  機能ID: FUNC_ID_PRICE_OBSERVER (200)
┃  主要機能:
┃   - Bid/Ask価格取得
┃   - スプレッド計算（ポイント単位）
┃   - 価格データのCLA_Dataへの格納
┃  実装状態: ✅ 実装済み
┃
┗━ CObservationRSI.mqh
   クラス名: CObservationRSI
   役割: RSI（相対力指数）の観測
   機能ID: FUNC_ID_TECHNICAL_RSI (205)
   主要機能:
    - RSI計算（iRSI関数使用）
    - RSI値のCLA_Dataへの格納
   実装状態: ✅ 実装済み

■ Layer 3: Decision（判断層）
┣━ CDecisionBase.mqh
┃  クラス名: CDecisionBase（基底クラス）
┃  役割: 判断モジュールの基底クラス
┃  主要機能:
┃   - Update()メソッド（判断更新）※仮想関数
┃   - IsCompleted()メソッド（完了判定）※Phase 6追加
┃   - シグナル生成（SIGNAL_BUY/SELL/NONE）
┃  実装状態: ✅ 実装済み
┃
┗━ CDecisionRSI_Simple.mqh
   クラス名: CDecisionRSI_Simple
   役割: RSIベースの売買判断
   機能ID: FUNC_ID_LOGIC_RSI_SIMPLE (310)
   主要機能:
    - RSI閾値判定（買われすぎ/売られすぎ）
    - シグナル生成（BUY/SELL/NONE）
    - Phase 6: 判断結果ログ（LOG_ID 110, 111）
   実装状態: 🟡 部分実装
   不足機能: LOG_ID 110, 111のログ出力実装確認

■ Layer 4: Execution（実行層）
┣━ CExecutionBase.mqh
┃  クラス名: CExecutionBase（基底クラス）
┃  役割: 注文実行の基底クラス
┃  主要機能:
┃   - OrderSend()ラッパー
┃   - OrderModify()ラッパー
┃   - OrderClose()ラッパー
┃   - エラーハンドリング
┃  実装状態: ✅ 実装済み
┃
┗━ CExecutionManager.mqh
   クラス名: CExecutionManager
   役割: 実行要求の処理（PLACE/MODIFY/CANCEL）
   機能ID: FUNC_ID_ORDER_GENERATOR (400)
   主要機能:
    - ProcessRequest()メソッド（要求振り分け）
    - 注文配置（PLACE）
    - 注文変更（MODIFY）
    - 注文取消（CANCEL）
    - Phase 6: 実行結果ログ（LOG_ID 101-103, 108）
   実装状態: 🟡 部分実装
   不足機能: LOG_ID 101-103, 108のログ出力実装確認

■ Layer 5: Strategy（戦略層）
┣━ CStrategy_OCOFollow.mqh
┃  クラス名: CStrategy_OCOFollow
┃  役割: OCO（Buy Stop/Sell Stop）追従戦略
┃  主要機能:
┃   - OCO注文配置
┃   - 未約定注文の価格追従（MODIFY）
┃   - 片側約定時の反対側取消
┃   - スプレッドチェック
┃   - Phase 2-1: ログ状態管理変数（完了）
┃   - Phase 6: 戦略層ログ（LOG_ID 100, 104-107, 109）
┃  実装状態: 🟡 部分実装
┃  不足機能:
┃   - EnterState()メソッド未実装
┃   - GetState()メソッド未実装
┃   - 直接代入（m_state = ...）の修正（9箇所）
┃   - LOG_ID 100, 104-107, 109のログ出力未実装
┃
┗━ CStrategyManager.mqh
   クラス名: CStrategyManager
   役割: アクティブな戦略の管理・呼び出し
   主要機能:
    - Strategy登録（Init）
    - 毎Tick Strategy更新（Update）
    - 完了検知（IsCompleted）
    - Phase 6: COMPLETED後も呼び続ける仕様対応
   実装状態: ✅ 実装済み

■ 外部ライブラリ
┣━ EXMQL.mqh
┃  役割: MQL取引ライブラリ
┃  主要機能: OrderSend/Modify/Close等のラッパー
┃  実装状態: ✅ 実装済み
┃
┗━ errordescription.txt
   役割: エラーコード定義
   主要機能: trade server / runtime error codes
   実装状態: ✅ 実装済み

========================================
2. インクルード依存関係ツリー
========================================

Aegis_Hybrid.mq4 / Aegis_Hybrid.mq5 (エントリーポイント)
└── Aegis_Core.mqh (全体制御)
    ├── CLA/00_Common/CLA_Common.mqh (共通定義)
    ├── CLA/00_Common/CLA_Data.mqh (共有状態管理)
    │   ├── CLA_Common.mqh ← 再利用
    │   └── CFileLogger.mqh (ログ実装)
    │       ├── ILogger.mqh (インターフェース)
    │       ├── CLA_Common.mqh ← 再利用
    │       └── EXMQL/EXMQL.mqh (外部ライブラリ)
    ├── CLA/01_Gatekeeper/CGatekeeper.mqh (安全制御)
    │   ├── CLA_Common.mqh ← 再利用
    │   └── CLA_Data.mqh ← 再利用
    ├── CLA/02_Observation/CObservationPrice.mqh (価格観測)
    │   ├── CObservationBase.mqh (基底クラス)
    │   │   ├── CLA_Common.mqh ← 再利用
    │   │   └── CLA_Data.mqh ← 再利用
    │   ├── CLA_Common.mqh ← 再利用
    │   └── CLA_Data.mqh ← 再利用
    ├── CLA/02_Observation/CObservationRSI.mqh (RSI観測)
    │   ├── CObservationBase.mqh ← 再利用
    │   ├── CLA_Common.mqh ← 再利用
    │   └── CLA_Data.mqh ← 再利用
    ├── CLA/03_Decision/CDecisionRSI_Simple.mqh (RSI判断)
    │   ├── CDecisionBase.mqh (判断基底クラス)
    │   │   ├── CLA_Common.mqh ← 再利用
    │   │   └── CLA_Data.mqh ← 再利用
    │   └── CObservationRSI.mqh ← 再利用
    ├── CLA/04_Execution/CExecutionBase.mqh (実行基底)
    │   ├── CLA_Common.mqh ← 再利用
    │   ├── CLA_Data.mqh ← 再利用
    │   └── EXMQL/EXMQL.mqh ← 再利用
    ├── CLA/04_Execution/CExecutionManager.mqh (実行管理)
    │   ├── CLA_Common.mqh ← 再利用
    │   ├── CLA_Data.mqh ← 再利用
    │   ├── CExecutionBase.mqh ← 再利用
    │   └── EXMQL/EXMQL.mqh ← 再利用
    ├── CLA/05_Strategy/CStrategy_OCOFollow.mqh (OCO戦略)
    │   ├── CLA_Common.mqh ← 再利用
    │   ├── CLA_Data.mqh ← 再利用
    │   └── CDecisionBase.mqh ← 再利用
    └── CLA/05_Strategy/CStrategyManager.mqh (戦略管理)
        ├── CLA_Data.mqh ← 再利用
        └── CDecisionBase.mqh ← 再利用

【依存関係の特徴】
- ✅ 循環依存なし: 全てのレイヤーは下位レイヤーのみに依存
- ✅ 共通定義の再利用: CLA_Common.mqh, CLA_Data.mqhは各所で参照
- ✅ レイヤー境界明確: 上位レイヤーが下位レイヤーを直接参照しない設計

========================================
3. 機能ID（ENUM_FUNCTION_ID）マッピング
========================================

FUNC_ID_NONE         = 0    (未使用)
FUNC_ID_MAIN_CONTROL = 1    (Aegis_Core.mqh)

■ Layer 0: Common (0-99)
FUNC_ID_COMMON_BASE  = 10   (CLA_Common.mqh)
FUNC_ID_CLA_DATA     = 900  (CLA_Data.mqh)

■ Layer 1: Gatekeeper (100-199)
FUNC_ID_GATEKEEPER    = 100 (CGatekeeper.mqh)
FUNC_ID_KILL_SWITCH   = 101 (未実装)
FUNC_ID_HEALTH_MONITOR = 102 (未実装)

■ Layer 2: Observation (200-299)
FUNC_ID_PRICE_OBSERVER   = 200 (CObservationPrice.mqh)
FUNC_ID_TIME_SIGNAL      = 201 (未実装)
FUNC_ID_ECONOMIC_SIGNAL  = 202 (未実装)
FUNC_ID_TECHNICAL_MA     = 203 (未実装)
FUNC_ID_TECHNICAL_MACD   = 204 (未実装)
FUNC_ID_TECHNICAL_RSI    = 205 (CObservationRSI.mqh)
FUNC_ID_TECHNICAL_STOCH  = 206 (未実装)
FUNC_ID_SIGNAL_INTEGRATOR = 210 (未実装)

■ Layer 3: Decision (300-399)
FUNC_ID_ENVIRONMENT_JUDGE  = 300 (未実装)
FUNC_ID_DECISION_EVALUATOR = 301 (未実装)
FUNC_ID_EXTERNAL_CONFIG    = 302 (未実装)
FUNC_ID_HOT_RELOAD         = 303 (未実装)
FUNC_ID_LOGIC_RSI_SIMPLE   = 310 (CDecisionRSI_Simple.mqh)

■ Layer 4: Execution (400-499)
FUNC_ID_ORDER_GENERATOR  = 400 (CExecutionManager.mqh)
FUNC_ID_POSITION_MANAGER = 401 (未実装)
FUNC_ID_TRAILING_MANAGER = 402 (未実装)
FUNC_ID_CLOSE_JUDGE      = 403 (未実装)

■ Layer 5: Logging (500-599)
FUNC_ID_STRUCTURED_LOGGER = 500 (CFileLogger.mqh)

========================================
4. ログID（ENUM_LOG_ID）マッピング
========================================

■ 100番台: 通常状態ログ（Phase 6）
LOG_ID_OCO_PLACE     = 100 (OCO配置成功)
LOG_ID_MODIFY_TRY    = 101 (注文変更試行)
LOG_ID_MODIFY_OK     = 102 (注文変更成功)
LOG_ID_MODIFY_FAIL   = 103 (注文変更失敗)
LOG_ID_NO_CHANGE     = 104 (価格変更不要)
LOG_ID_SPREAD_SKIP   = 105 (スプレッド超過)
LOG_ID_SPREAD_OK     = 106 (スプレッド正常化)
LOG_ID_TRAIL_TRIGGER = 107 (追従トリガー)
LOG_ID_CANCEL_OK     = 108 (注文取消成功)
LOG_ID_FILL_DETECT   = 109 (約定検出)
LOG_ID_RSI_DECISION  = 110 (RSI判断)
LOG_ID_DECISION_SKIP = 111 (判断スキップ)

■ 1000番台: Gatekeeper層（将来拡張用）
LOG_ID_GATEKEEPER    = 1000 (予約)

■ 2000番台: Observation層（将来拡張用）
LOG_ID_OBSERVATION   = 2000 (予約)

■ 3000番台: Execution層（既存）
LOG_ID_EXEC_PLACE    = 3001 (注文配置)
LOG_ID_EXEC_MODIFY   = 3002 (注文修正)
LOG_ID_EXEC_CANCEL   = 3003 (注文取消)
LOG_ID_EXEC_CLOSE    = 3004 (ポジション決済)

■ 4000番台: Decision層（将来拡張用）
LOG_ID_DECISION      = 4000 (予約)

■ 5000番台: Strategy層（将来拡張用）
LOG_ID_STRATEGY      = 5000 (予約)

========================================
5. 実装状態サマリー
========================================

【完全実装】✅
- Aegis_Core.mqh (制御層)
- Aegis_Hybrid.mq4/mq5 (エントリーポイント)
- CLA_Common.mqh (共通定義)
- ILogger.mqh (ログインターフェース)
- CObservationBase.mqh (観測基底)
- CObservationPrice.mqh (価格観測)
- CObservationRSI.mqh (RSI観測)
- CDecisionBase.mqh (判断基底)
- CExecutionBase.mqh (実行基底)
- CStrategyManager.mqh (戦略管理)
- EXMQL.mqh (外部ライブラリ)

【部分実装】🟡
- CLA_Data.mqh (AddLogEx確認必要)
- CFileLogger.mqh (CSV 10カラム対応必要)
- CGatekeeper.mqh (Phase 6ログ確認必要)
- CDecisionRSI_Simple.mqh (ログ出力確認必要)
- CExecutionManager.mqh (ログ出力確認必要)
- CStrategy_OCOFollow.mqh (Phase 2-1完了必要、ログ未実装)

【未実装】❌
- 経済指標観測（CObservationEconomic）
- 環境認識機能（FUNC_ID_ENVIRONMENT_JUDGE）
- ポジション追従戦略（CStrategy_Trailing系）
- パニックログ本実装（CriticalSnapshotLogger）
- スポットログ本実装（SpotLogger）

========================================
6. 次のステップ
========================================

優先度1: Phase 6完了（9日）
 - Task 1: Phase 2-1完了（0.5日）
 - Task 2-8: ログ実装（5.5日）
 - Task 9: 長期テスト（3日）

優先度2: 高優先機能（5日）
 - ポジション追従戦略（3日）
 - 環境認識機能（2日）

優先度3: Phase 7実装（7日）
 - パニックログ（2日）
 - スポットログ（2日）
 - 経済指標観測（3日）

総所要期間: 約4.5週間（22日）

========================================




================================================================================
Aegis Hybrid EA
状態ログ実装仕様書 v3.4（最終版）
================================================================================

作成日: 2026-01-03
作成者: Genspark AI (PM) + ChatGPT (設計思想) + Claude (実装レビュー) + Yasuharu (最終承認)
対象: Aegis Hybrid EA - 状態ログ基盤

================================================================================
変更履歴
================================================================================

| バージョン | 日付 | 変更内容 | 変更者 |
|-----------|------|---------|--------|
| v1.2 | 2026-01-02 | 叩き台作成 | Genspark AI |
| v2.0 | 2026-01-02 | 正式版 | ChatGPT |
| v2.1 | 2026-01-02 | Claude実装レビュー反映 | Genspark AI + ChatGPT |
| v3.0 | 2026-01-03 | Phase番号削除・抽象化・普遍化 | Yasuharu + Genspark AI |
| v3.1 | 2026-01-03 | ヤスハルコメント反映・修正 | Genspark AI |
| v3.2 | 2026-01-03 | 実装者レビュー反映・確定 | Genspark AI + Claude + Yasuharu |
| v3.3 | 2026-01-03 | 測定方法追加・Param4統一 | Yasuharu + ChatGPT + Genspark AI |
| **v3.4** | **2026-01-03** | **ChatGPTレビュー反映・最終版** | **Genspark AI + ChatGPT + Yasuharu** |

### v3.4 の主要変更点（ChatGPTレビュー反映）

1. **状態の二重性を明確化**
   - 2.8節（用語の定義）に「STATE vs 状態変化」の説明を追加
   - 本仕様書における「状態」が指すものを明文化

2. **LogLevelとPanic Logの関係を明記**
   - 4.3節に「致命的状況はLogID帯（200番台）で区別する」旨を追加
   - FATALを使用しない理由を明確化

3. **5万件Flush責任の明記**
   - 5.2節に「Flush判定はLogger内部で完結」を追加
   - 呼び出し側（Strategy等）は関知しない旨を明記

4. **1.7節 成功条件の測定方法を追加**
   - 測定可能な基準を明示
   - CSV単体で完結する検証方法を記載

### v3.2 からの主要変更点（参考）

1. **ログ機能の責務を明文化**
   - 「記録装置」としての責務を第1章で宣言
   - 判断・状態・抑制ロジックを持たないことを明記

2. **価格表現方法の確定**
   - ポイント単位整数値に統一
   - 「整数＋桁数」方式を削除

3. **回数記録方法の確定**
   - Param4に継続回数を記録
   - 「別途検討」を削除

4. **ログ独立性の方針確定**
   - 各層でフラグ管理
   - 「ログ機能の内部」記述を削除
   - 妥協条件を明記

5. **第2章・第7章の統合**
   - 設計思想（WHY）を第2章に集約
   - 第7章は実装時の注意事項のみ

6. **用語集の追加**
   - 2.8節として用語の定義を追加
   - 「状態変化」「状態遷移」「イベント」を統一

7. **Param1-4の推奨用途明記**
   - 4.2.3節として追加
   - 実装者の迷いを削減

8. **文字列長の単位統一**
   - 100バイトに統一（文字数ではなく）

9. **1万件強制出力の見直し**
   - 5万件に変更

10. **番号体系の簡素化**
    - 1000番台以降の詳細を削除
    - 「実装時に決定」に変更

11. **容量計算の修正**
    - 実測値ベースに修正

12. **第9章の簡素化**
    - 詳細記述を削除

================================================================================
第1章 概要・目的・成功条件
================================================================================

1.1 本章の目的
----------------------------------------------------------------

本章は、Aegis Hybrid EA における **状態ログ実装** の目的・範囲・成功条件を定義する。

1.2 位置づけ
----------------------------------------------------------------

状態ログは、EAの売買ロジックや戦略を変更せず、**「なぜその動作をしたかを後から説明できる状態にするための骨格作り」** を目的とする。

- ログの網羅性・最適化・美観は対象外
- 後続で拡張・洗練する前提とする

**重要原則:**
ログの追加・削除によってメインロジックの挙動に影響を与えてはならない。

1.3 ログ機能の責務
----------------------------------------------------------------

**ログ機能は「記録装置」である。**

- 判断もしない
- 状態も持たない
- 抑制ロジックも持たない

**唯一の責務:**
「渡された事実を、壊さず、漏らさず、静かに記録する」

**設計原則:**
「ログ有効／無効でメインロジックの挙動は変わらない」

1.4 目的
----------------------------------------------------------------

- トレード結果に対し、事後分析が可能なログを残す
- 「なぜ動いたか／なぜ動かなかったか」を追跡可能にする
- 毎Tickログを避け、実運用に耐える記録量に抑制する

1.5 範囲
----------------------------------------------------------------

**含めるもの:**
- 通常状態ログ（100番台）
- 状態遷移ベースの記録ルール
- CSV出力基盤
- 記録種別番号体系の確定と予約

**含めないもの:**
- パニックログの本実装（200番台）
- スポットログの本実装（300番台）
- ログを用いた判断・制御機構

1.6 成功条件
----------------------------------------------------------------

成功条件は以下とする。

1. ログを見て「なぜそう動作したか」を説明できる
2. LogIDとパラメータの意味が仕様書と一致している
3. 毎Tickログが発生しない
4. 長期テスト（1か月程度）でログ量が実用範囲に収まる

1.7 成功条件の測定方法
----------------------------------------------------------------

上記の成功条件を以下の方法で測定可能とする。

**1. 説明可能性の測定:**
- CSV を Excel で開き、ランダムに10行を抽出
- 各行について「なぜこのログが出たか」を5秒以内に説明できるか
- 説明できない行が3行以上ある場合は失敗

**2. LogID一致の測定:**
- ソースコード内のAddLogEx()呼び出しと、CSV内のLogIDを照合
- LogNameが仕様書またはソースコメントと一致しているか

**3. 毎Tickログの検出:**
- CSV の TickSeq 列をソート
- 連続する TickSeq で同一LogIDが5回以上出現する場合、毎Tickログの疑い
- 該当箇所をソースで確認し、状態変化以外でログ出力していないか検証

**4. ログ量の検証:**
- 1か月テスト後の CSV ファイルサイズを確認
- 5 MB 以下であれば合格
- 20,000 行以下であれば合格

**測定の重要性:**
- これらの測定方法は専用ツールを要求しない
- Excel と目視確認で完結する
- 運用者・実装者・将来の自分の誰もが実施可能

================================================================================
第2章 設計思想（Aegisログ設計原則）
================================================================================

2.1 基本思想
----------------------------------------------------------------

Aegisのログ設計は、以下の思想を前提とする。

> **「なぜ負けたかわからない」を最大の失敗とする**

2.2 判断と報告の分離
----------------------------------------------------------------

- ログは **起きた事象を記録するのみ**
- ログ記録層は、売買判断・制御判断を行わない

**ログ記録処理内で以下を行ってはならない:**
- 状態遷移の判断
- パラメータ補正
- 処理分岐の決定

**ログは常に「判断の後」に呼び出される。**

2.3 状態変化時のみ記録
----------------------------------------------------------------

**「状態変化」とは以下を指す:**

1. **状態遷移**
   - STATE_IDLE → STATE_FOLLOWING 等の状態変化
   
2. **閾値超過**
   - スプレッドが正常範囲を超えた瞬間
   - 価格差が一定値を超えた瞬間
   
3. **イベント発生**
   - 注文約定
   - 注文配置成功/失敗
   - エラー発生

**記録方針:**
- 毎Tickの価格更新ではログを出力しない
- 状態が「変化した瞬間」のみ記録する
- 同一状態が継続する場合は初回のみ記録し、**継続回数をカウント**する

**回数記録の扱い（確定）:**
- 同一状態の継続回数はParam4に記録
- 状態変化時にカウンタ値をログ出力
- これにより「何回連続したか」を追跡可能にする

**具体例:**

良い例（記録すべき）:
- スプレッド: 正常（20pips）→異常（50pips） ✅
- 価格差分: 閾値未満（3pips）→閾値超過（10pips） ✅
- 注文状態: 未約定→約定 ✅

悪い例（記録不要）:
- スプレッド: 異常（50pips）→異常（51pips） ❌（状態継続）
- 価格: 毎Tickの更新 ❌（状態変化なし）
- 価格差分: 閾値超過（10pips）→閾値超過（11pips） ❌（状態継続）

**判断基準:**
「状態の種類」が変わった時のみ記録する。
同じ状態内での数値変化は記録しない。

2.4 説明可能性の優先
----------------------------------------------------------------

- ログは最小ではなく「理解可能」を優先する
- 数値（価格・差分・閾値）を必ず記録対象に含める
- 省略によって判断理由が不明になる設計を避ける

**パニックログ・スポットログとの連携:**
- 通常ログで異常の「兆候」を記録
- パニックログで致命的状況の「詳細」を記録
- スポットログで特定条件下の「詳細観測」を記録
- これら3種のログが補完し合う設計とする

2.5 型安全性の確保
----------------------------------------------------------------

**数値パラメータは数値型のみ使用:**

**価格・指標値の表現（確定）:**
- Param1-4には「ポイント単位の整数値」を記録
- 例: 150.123円（3桁通貨） → 150123ポイント
- 例: スプレッド5pips → 50ポイント
- これにより1価格=1パラメータで済む
- 桁数情報は通貨ペアから自動判定可能（不要）

**その他の数値:**
- 整数: チケット番号、回数、状態コード

**文字列は説明文フィールドのみに限定:**
- 文字列長は最大100バイト（UTF-16LE換算で約50文字）
- 超過時はAddLogEx()内で強制カット
- カット位置: 97バイト目で切断 + "..." 付加（計100バイト）

2.6 段階実装前提
----------------------------------------------------------------

- 骨格のみを実装
- 仕様は後方互換を前提に拡張可能とする
- ロールバック可能な実装順序を維持する

**ロールバックとは:**
- 実装を前の状態に安全に戻せること
- 各実装ステップは独立して動作可能
- 新機能追加が既存機能を破壊しない設計

**ロールバック実装方法:**

方法1: Git運用
- 各実装ステップでコミット
- 問題発生時は git revert で戻す

方法2: フラグ制御
- 新機能を外部パラメータで ON/OFF 可能にする
- 例: input bool InpEnableNewLog = false;

方法3: 段階的有効化
- 新LogIDを追加しても、最初は出力しない
- テスト完了後に有効化

推奨: 方法1+方法2の併用

2.7 ログ抑制フラグの管理
----------------------------------------------------------------

**管理場所（確定）:**
- ログ抑制用フラグは **各層（Strategy/Decision/Execution）** で管理する
- 例: 戦略クラスがスプレッド状態を管理し、変化時のみログ出力
- ログ機能（CFileLogger）は受け取ったログをそのまま記録

**理由:**
- ログ機能は「状態判断」を行わない（2.2節の原則に従う）
- 状態判断は各層の責務
- ログ機能は記録のみに専念

**妥協条件:**
「ログ有効／無効でメインロジックの挙動は変わらない」を満たせば、
独立性は確保されているとみなす。

2.8 用語の定義
----------------------------------------------------------------

本仕様書で使用する用語を以下に定義する。

| 用語 | 定義 |
|------|------|
| **ログ抑制フラグ** | 同一ログの連続出力を防ぐための内部フラグ。各層で管理。 |
| **状態変化** | 以下の3種を指す：(1)状態遷移、(2)閾値超過、(3)イベント発生 |
| **状態遷移** | STATE_IDLE → STATE_FOLLOWING 等の明示的な状態変化 |
| **閾値超過** | スプレッド正常→異常 等の境界値を超えた瞬間 |
| **イベント発生** | 約定、エラー発生 等の離散的な出来事 |
| **ポイント** | 価格の最小単位（通貨ペアに依存しない表現）。例: 0.001円、0.00001ドル |
| **継続回数** | 同一状態が連続した回数。Param4に記録。 |

**「状態」という言葉の二重性について:**

本仕様書における「状態」とは、以下の2つの意味を持つ場合がある：

1. **戦略上のSTATE**: CStrategy_OCOFollow の STATE_IDLE、STATE_FOLLOWING 等
2. **ログ観点の状態変化**: スプレッド正常/異常、閾値未満/超過 等

これら2つは必ずしも一致しない。
例: 戦略がSTATE_FOLLOWINGのままでも、ログ観点では「スプレッド正常→異常」という状態変化が発生しうる。

本仕様書では文脈により両方の意味を使い分けている。
混乱を避けるため、明示的に「STATE」と記載する場合は戦略上の状態を指し、
「状態変化」と記載する場合はログ記録のトリガーを指す。

================================================================================
第3章 ログ分類と番号体系
================================================================================

3.1 番号体系の目的
----------------------------------------------------------------

ログの種類を **番号帯で明確に分離** し、将来の拡張・解析・自動処理を容易にする。

3.2 番号体系（確定）
----------------------------------------------------------------

**確定済み:**

| 番号帯 | 分類 | 状態 | 備考 |
|--------|------|------|------|
| **100番台** | 通常状態ログ | 実装対象 | Strategy層 |
| **200番台** | パニックログ | 予約 | 全層共通 |
| **300番台** | スポットログ | 予約 | 全層共通 |

**将来定義:**

| 番号帯 | 分類 | 状態 |
|--------|------|------|
| **1000番台以降** | 各層専用ログ | 実装時に決定 |

**注意:**
- 1000番台以降の詳細割り当ては、各層実装時に決定
- 番号の1000番刻みは目安であり、厳密ではない
- 重要なのは「番号重複を避ける」こと

3.3 100番台（通常状態ログ）の位置づけ
----------------------------------------------------------------

- 実装する唯一のログ分類
- 戦略・判断・実行の結果として起きた事象を記録
- 状態遷移・閾値超過・イベント発生時のみ出力

3.4 200番台（パニックログ）の位置づけ
----------------------------------------------------------------

- 将来実装
- 致命的異常時の記録を想定

**重要:** 致命的状況の扱いは LogLevel（INFO/WARN/ERROR）ではなく、
LogID番号帯（200番台）で区別する設計とする。

**理由:**
- パニックログは通常ログとは異なる記録方針・出力タイミングを持つ
- LogLevelでの区別では、フィルタリングや後処理が複雑化する
- 番号帯での区別により、ログ種別が明確になる

3.5 300番台（スポットログ）の位置づけ
----------------------------------------------------------------

- 将来実装
- デバッグ・調査用途の条件付き記録を想定

3.6 LogIDの一元管理
----------------------------------------------------------------

**管理方法（確定）:**
- 全LogIDはCLA_Common.mqhの enum ENUM_LOG_ID で一元管理
- 新規LogID追加時は必ずこのenumに追加
- これにより番号重複を防止

3.7 将来拡張方針
----------------------------------------------------------------

- 番号帯の意味は固定とする
- 番号の欠番は将来用途のため許容する
- 番号帯を跨ぐ意味の混在は禁止する
- LogIDは随時追加される

================================================================================
第4章 通常状態ログ（100番台）の仕様
================================================================================

4.1 本章の目的
----------------------------------------------------------------

本章は、実装する **通常状態ログ（100番台）** の仕様を定義する。

ログの目的は、EAの動作を **事後に説明可能** にすることであり、挙動の最適化や戦略改善は対象外とする。

4.2 ログ出力形式（共通）
----------------------------------------------------------------

### 4.2.1 出力形式

ログは CSV 形式で出力する。

```
Time_ms,TickSeq,Level,LogID,LogName,Param1,Param2,Param3,Param4,Message
```

### 4.2.2 各フィールド定義

| フィールド | 型 | 内容 |
|-----------|-----|------|
| Time_ms | 整数 | ミリ秒単位の時刻 |
| TickSeq | 整数 | 市場価格更新番号（連番） |
| Level | 固定文字列 | INFO / WARN / ERROR |
| LogID | 整数 | 記録種別識別子 |
| LogName | 固定文字列 | 記録種別名称（最大32文字） |
| Param1〜4 | 数値 | LogID固有のパラメータ |
| Message | 文字列 | 補足説明（最大100バイト） |

### 4.2.3 Param1-4の推奨用途（確定）

| パラメータ | 推奨用途 | 例 |
|-----------|---------|-----|
| Param1 | 主要な識別子 | チケット番号、注文番号 |
| Param2 | 主要な数値 | 価格（ポイント単位）、スプレッド（ポイント単位） |
| Param3 | 副次的な数値 | 差分、閾値（ポイント単位） |
| Param4 | 継続回数、または補助情報 | 連続発生回数、エラーコード |

**例（LOG_ID_MODIFY_OK）:**
- Param1: チケット番号
- Param2: 変更後の価格（ポイント）
- Param3: 変更前の価格（ポイント）
- Param4: 連続変更回数

4.3 重要度（Level）の定義
----------------------------------------------------------------

| 重要度 | 意味 |
|--------|------|
| INFO | 正常な状態変化 |
| WARN | 想定内だが注意が必要な状態 |
| ERROR | 処理継続可能な異常 |

※ FATAL は使用しない。

**FATALを使用しない理由:**
- 致命的状況はLogID番号帯（200番台：パニックログ）で区別する
- これにより、致命的状況は専用の記録方針・出力タイミングで処理される
- LogLevelは「通常ログ内での重要度」を示すのみ

4.4 通常状態ログ一覧（100番台）
----------------------------------------------------------------

| LogID | 名称 | 概要 |
|-------|------|------|
| 100 | OCO_PLACE | 両建て注文配置成功 |
| 101 | MODIFY_TRY | 注文価格変更試行 |
| 102 | MODIFY_OK | 注文価格変更成功 |
| 103 | MODIFY_FAIL | 注文価格変更失敗 |
| 104 | NO_CHANGE | 価格変更不要 |
| 105 | SPREAD_SKIP | スプレッド超過により追従中断 |
| 106 | SPREAD_OK | スプレッド正常化により追従再開 |
| 107 | TRAIL_TRIGGER | トレイル発動 |
| 108 | CANCEL_OK | 注文取消成功 |
| 109 | FILL_DETECT | 約定検出 |
| 110 | DECISION | 判断結果記録 |
| 111 | DECISION_SKIP | 判断保留理由記録 |

**重要:**
- **各LogIDはユニーク番号**である
- これにより「何があったか」をソースコードから追跡可能
- 各層で独自のLogIDを定義し、番号重複を避ける

**補足:**
- 各LogIDのパラメータ詳細は実装ドキュメントまたはソースコード内コメントで管理
- 仕様書には個別定義を含めない（実装の自由度確保）

4.5 記録ルール
----------------------------------------------------------------

### 4.5.1 状態変化時のみ記録

- 状態が変化した瞬間のみログを出力する
- 同一状態の連続記録は **まとめる**
- まとめ方：初回記録 + 継続回数カウント → 状態変化時にParam4へ回数出力

### 4.5.2 変化量閾値ルール

- 数値変化が微小な場合は記録しない
- 閾値は外部パラメータで制御する

================================================================================
第5章 ログ記録の抑制と爆発対策
================================================================================

5.1 ログ抑制の原則
----------------------------------------------------------------

ログ抑制は以下の優先順位で判定する:

**優先度1: 状態遷移の有無**
- 状態遷移あり → ログ出力候補
- 状態遷移なし → ログ抑制候補

**優先度2: 初回記録フラグ**
- 同一状態の初回のみ記録

5.2 ログ爆発対策
----------------------------------------------------------------

**規定件数による強制出力（修正）:**
- ログ記録件数が **5万件** に達した時点で、自動的にファイルへ出力する
- 出力後、メモリ上のログをクリアし、次の記録を開始する
- この機構により、メモリ不足によるEA停止を防ぐ

**Flush判定の責任（重要）:**
- このFlush判定は **ログ機能内部（CFileLogger）** で完結する
- 呼び出し側（Strategy / Decision / Execution 等）は関知しない
- ログ機能は「5万件に達したら自動的にFlush」を自律的に実行
- 呼び出し側は単にAddLogEx()を呼ぶだけでよい

**根拠:**
- 5万件 × 115バイト = 約 5.7 MB（十分小さい）
- 月1回の出力で済む（月間想定15,000-20,000行）
- メモリ逼迫のリスクも低い

**戦略ロジックによる出力タイミング促進:**
- トレード終了時
- 日次切替時
- 重要イベント発生時
- これらのタイミングで明示的にFlush()を呼び出し可能（任意）

**出力タイミングの制御:**
- OnTick()内では出力しない
- OnTimer()またはOnDeinit()で出力
- これにより OnTick() の処理時間を安定化

**目的:**
- ログ量の無制限増加を防ぐ
- 異常時のメモリ保護
- 長期運用時の安定性確保

5.3 変化量閾値（仮の値）
----------------------------------------------------------------

以下は暫定的な仮の値であり、実装後の調整により変更される可能性がある。

- 価格差分無視閾値: 0.5pips相当
- スプレッド変化量ログ閾値: 1.0pips相当

**補足:**
- 確定値は調整により随時変更されるため、仕様書への固定記載はしない
- 実装時は外部パラメータとして調整可能にする

================================================================================
第6章 記録量見積もり
================================================================================

6.1 見積もりの前提条件
----------------------------------------------------------------

本見積もりは、以下の条件を前提とする。

- 対象：通常状態ログ（100番台）のみ
- 記録方式：状態変化時のみ記録
- 毎Tickログ：行わない
- テスト実績：
  - 約 2,100,000 Tick / 月
  - 約 639 トレード / 月

6.2 記録頻度の想定
----------------------------------------------------------------

### 6.2.1 主な記録発生ポイント

| 種別 | 想定発生頻度 |
|------|-------------|
| 注文配置 | トレード開始時のみ |
| 追従発動 | 数回〜十数回 / トレード |
| 変更成功 / 失敗 | 追従発動時のみ |
| 追従中断 / 再開 | 状態変化時のみ |
| 判断記録 | 判断確定時のみ |
| 判断保留 | 状態変化時のみ |

### 6.2.2 トレードあたりの想定ログ数

- 最小：5〜8行
- 平均：15〜25行
- 最大（荒い相場）：50行程度

**注意:**
- この値は仮定義
- 実装後のバックテストで実測し、調整する

6.3 月間ログ行数見積もり
----------------------------------------------------------------

### 6.3.1 計算式

```
月間ログ行数 ≒ トレード数 × 平均ログ数
```

### 6.3.2 見積もり結果

```
639 トレード × 15〜25 行
→ 約 9,585〜15,975 行 / 月
→ 概算: 約 10,000〜15,000 行 / 月
```

※ スプレッド急変など特殊条件を含めても20,000 行 / 月を超えることは想定しない

6.4 ファイル容量見積もり（修正）
----------------------------------------------------------------

### 6.4.1 1行あたりの容量（実測ベース）

| 項目 | 想定サイズ |
|------|-----------|
| 数値フィールド | 約 65 バイト |
| 名称フィールド | 約 10 バイト（平均） |
| 説明文 | 約 30 バイト（平均） |
| 区切り・制御文字 | 約 10 バイト |
| **合計（平均）** | **約 115 バイト / 行** |
| **合計（最大）** | **約 175 バイト / 行** |

### 6.4.2 月間容量

```
15,000 行 × 115 バイト = 約 1.7 MB / 月（平均）
15,000 行 × 175 バイト = 約 2.6 MB / 月（最大）
```

### 6.4.3 年間容量（参考）

```
約 20〜32 MB / 年（通常状態ログのみ）
```

6.5 パフォーマンス影響評価
----------------------------------------------------------------

### 6.5.1 CPU負荷
- 状態変化時のみ書き込み
- 毎Tick処理への影響は無視できるレベル

### 6.5.2 IO負荷
- 書き込み頻度が低いため問題なし
- CSV追記方式を前提

6.6 ログ爆発リスク評価
----------------------------------------------------------------

### 6.6.1 想定されるリスク
- 状態判定ロジックの誤実装
- 状態フラグ未リセットによる多重記録

### 6.6.2 抑制策
- 状態フラグ管理の厳密化
- IDLE遷移時の明示的リセット
- 規定件数（5万件）での強制出力

6.7 結論
----------------------------------------------------------------

- 月間ログ量：現実的かつ管理可能
- ストレージ・性能への影響：問題なし
- 目的（説明可能性）を阻害しない

================================================================================
第7章 実装時の注意事項
================================================================================

7.1 毎Tick記録の禁止
----------------------------------------------------------------

市場価格更新（OnTick）ごとの記録は禁止。

**記録対象は以下に限定する:**
- 状態遷移
- 閾値超過
- 初回発生イベント

**Tick回数はログのトリガー条件にしてはならない。**

7.2 状態フラグ管理の注意点
----------------------------------------------------------------

**static ローカル変数の使用禁止:**
- 理由1: 複数インスタンス間で状態が共有されてしまう
- 理由2: テスト時の初期化が困難
- 理由3: スレッドセーフでない
- 代替: クラスメンバ変数を使用

7.3 CSV出力の注意事項
----------------------------------------------------------------

**RFC4180 準拠のエスケープ処理を行う:**

RFC4180（CSV標準仕様）では、以下のルールを定義：
- フィールド内にカンマ・改行・ダブルクォートが含まれる場合、フィールド全体をダブルクォートで囲む
- ダブルクォート文字自体は2つ連続（""）でエスケープ
- 例: `Hello, "World"` → `"Hello, ""World"""`

**Aegisでの適用:**

| 対象 | エスケープ | 理由 |
|------|----------|------|
| 数値フィールド（Param1-4） | 不要 | 数値のみのため |
| LogID, Level | 不要 | 固定文字列のため |
| Message | 必要 | 自由記述のため |

**エスケープ対象文字:**
- `,`（カンマ）
- `"`（ダブルクォート）
- 改行文字（\n, \r\n）

**実装方針:**
- Message欄のみエスケープ処理を実施
- 数値・固定文字列はエスケープ不要

7.4 パフォーマンス上の注意
----------------------------------------------------------------

- 文字列生成は記録確定後のみ行う
- 抑制条件を満たさない場合、説明文生成は禁止
- ログ出力呼び出しは最小限にする

7.5 テスト時の注意事項
----------------------------------------------------------------

テストでは以下を重点確認:

- 意味のないログが出ていないか
- 状態遷移が欠落していないか
- ログ抑制が効きすぎていないか

**ログが「少なすぎる」場合は失敗とみなす。**

================================================================================
第8章 レビューおよび承認条件
================================================================================

8.1 レビュー観点（必須）
----------------------------------------------------------------

本仕様は、以下の観点でレビューされることを前提とする。

1. **説明可能性**: 各ログから「なぜその動作に至ったか」を追跡できるか
2. **過不足の有無**: ログが多すぎず、少なすぎないか
3. **設計思想の遵守**: 判断と記録の分離が守られているか
4. **将来拡張性**: パニック／スポットログへの拡張余地があるか

8.2 合格条件（GO基準）
----------------------------------------------------------------

以下すべてを満たした場合、**完了（GO）** とする。

- 通常状態ログが出力される
- ログ内容が人間にとって理解可能である
- 毎Tickログが一切発生していない
- CSVが後処理（Excel / スクリプト）で解析可能

**勝率・利益率は評価対象外。**

8.3 不合格条件（NO GO）
----------------------------------------------------------------

以下のいずれかに該当した場合、**差し戻し** とする。

- ログを見ても動作理由が説明できない
- 同一ログが大量に連続出力される
- 状態遷移がログに現れない
- 重要な判断が無記録で行われている
- 実装が仕様書と乖離している

================================================================================
第9章 将来実装への展望
================================================================================

9.1 将来実装の方針
----------------------------------------------------------------

- パニックログ（200番台）: 致命的異常の詳細記録
- スポットログ（300番台）: デバッグ用詳細記録
- 詳細は別仕様書で定義する

9.2 本仕様書のスコープ外
----------------------------------------------------------------

以下は **本仕様書では扱わない**。

- パニックログの詳細仕様
- スポットログの詳細仕様
- 各層個別のログ仕様
- メモリダンプ手法
- 外部解析ツール連携

**これらは将来実装時に別仕様書で定義する。**

================================================================================
第10章 まとめ ― 完成定義
================================================================================

10.1 完成条件（定義）
----------------------------------------------------------------

以下をすべて満たした時点で **完了（DONE）** とする。

1. 通常状態ログが安定して出力される
2. ログを読めば「なぜその動作をしたか／しなかったか」が説明できる
3. 毎Tickログが発生しない
4. ログによる性能劣化が実用上問題にならない
5. ログ設計が将来拡張を阻害しない

10.2 価値と最終宣言
----------------------------------------------------------------

本仕様により、Aegis は以下を獲得する。

- 「勝った／負けた」ではなく「なぜそうなったか」を説明できるEA
- AI・人間双方が解析可能なログ構造
- ロジック改善のための客観的証拠
- 将来拡張への安全な足場

**成功基準は唯一。**

> **意味のあるログが、安定して出ること**

**本実装の目的は「ログが信用できるか」を証明すること。**

**この仕様書は、Aegis が「ブラックボックス」になることを拒否するための最低限かつ十分な設計である。**

10.3 次実装への引き渡し事項
----------------------------------------------------------------

次実装に引き渡すもの：

- 確立された LogID 番号体系
- 状態遷移ログの設計思想
- 記録抑制ルール
- 型安全なCSV基盤
- 実運用で得られた知見

================================================================================
状態ログ実装仕様書 v3.4 完（最終版）
================================================================================



================================================================================
Aegis Hybrid EA
パニックログ／スポットログ 実装仕様書 v1.1
================================================================================

作成日: 2026-01-03
作成者: Genspark AI + Claude + Yasuharu
対象: Aegis Hybrid EA - パニックログ（200番台）/ スポットログ（300番台）

================================================================================
変更履歴
================================================================================

| バージョン | 日付 | 変更内容 | 変更者 |
|-----------|------|---------|--------|
| v0.1 | 2026-01-03 | ドラフト作成 | Yasuharu |
| v1.0 | 2026-01-03 | Claude/Gensparkレビュー反映・確定版 | Genspark AI + Claude + Yasuharu |
| **v1.1** | **2026-01-03** | **Claude軽微な提案反映・最終版** | **Genspark AI + Claude + Yasuharu** |

### v1.0 の主要変更点（レビュー反映）

1. **パニックログの記録タイミングを明確化**
   - 通常ログと同じメモリバッファに蓄積
   - 5万件到達時またはOnDeinit()でファイル出力
   - パニック発生時は可能な限り早期にFlush()を推奨

2. **スポットログの毎Tick出力を制限**
   - 毎Tick出力は推奨しない
   - テスト環境のみで短時間使用を許容
   - 本番環境では必ず無効化

3. **パニックLogIDを追従型OCO仕様書と対応**
   - PANIC_ENTERを削除
   - PANIC_BOTH_FILLED、PANIC_RECOVERY_FAILEDを追加
   - OCO戦略仕様書 v0.7 の異常ケースと対応

4. **OnDeinit関連記述を2.4節に集約**
   - 5.2節の重複記述を削除
   - OnDeinit時の制約を明記

5. **禁止事項に具体例を追加**
   - 通常ログでパニックを代替する誤用例
   - パニックログで通常ログを代替する誤用例
   - スポットログを恒常運用する誤用例

6. **前提仕様との関係を明記**
   - 状態ログ実装仕様書 v3.4 との継承関係
   - 継承する規約を列挙

7. **LogID割り当てルールを明記**
   - 200番台の内部割り当て（層別）
   - 300番台の内部割り当て（層別）

8. **完成条件を測定可能な基準に具体化**
   - 測定方法を追加
   - テスト観点を明記

9. **スポットログの具体例を追加**
   - 用途別のLogID例
   - 使用例コード

10. **第7-10章を追加**
    - 第7章: 記録量見積もり
    - 第8章: 測定方法とテスト観点
    - 第9章: FAQ
    - 第10章: まとめ

11. **用語定義にRECOVERY状態を追加**
    - 追従型OCO仕様書 v0.7 と整合

### v1.1 の主要変更点（Claude軽微な提案反映）

1. **2.5.1節に層別割り当ての具体例を追加**
   - 共通パニックの具体例: RETRY_EXCEEDED, DEINIT_ABNORMAL
   - Strategy層パニックの具体例: BOTH_FILLED, RECOVERY_FAILED

2. **9.3節 Q8に具体例を追加**
   - MODIFY失敗の判断基準を明記
   - 1-2回の失敗 → 通常ログ
   - 10回連続失敗 → パニックログ

3. **10.3節を維持**
   - 各層実装（1000番台以降）への橋渡しとして有用

================================================================================
第1章 共通方針（最重要）
================================================================================

1.1 ログ種別の位置づけ
----------------------------------------------------------------

| 種別 | 目的 | 性質 | 番号帯 |
|------|------|------|--------|
| 通常状態ログ | 動作説明 | 定常・抑制あり | 100番台 |
| パニックログ | 破綻の記録 | 非定常・抑制なし | 200番台 |
| スポットログ | 観測・調査 | 任意・条件付き | 300番台 |

**原則:**

> **パニックログ／スポットログは
メインロジックの挙動に一切影響を与えてはならない**

> **ログの有無でEAの動作が変わることは禁止**

この原則は状態ログ実装仕様書 v3.4（1.3節）と完全に一致する。

1.2 出力形式（共通）
----------------------------------------------------------------

CSV形式は通常状態ログと完全に共通。

```
Time_ms,TickSeq,Level,LogID,LogName,Param1,Param2,Param3,Param4,Message
```

**各フィールドの規約:**
- Param1〜4 の型・意味は通常ログの規約に準拠（v3.4 4.2.3節）
- Message は最大100バイト、RFC4180準拠（v3.4 2.5節）
- LogID は ENUM_LOG_ID で一元管理（v3.4 3.6節）

1.3 前提仕様との関係
----------------------------------------------------------------

本仕様は以下を前提とする。

**必須前提:**
- 状態ログ実装仕様書 v3.4（または v3.3）
- CSV基盤が実装済み
- AddLogEx()が使用可能
- ENUM_LOG_IDが一元管理されている

**継承する規約:**
- CSV形式（10列）
- Param1-4の型・意味（v3.4 4.2.3節）
- Messageの最大100バイト（v3.4 2.5節）
- RFC4180準拠（v3.4 7.3節）
- ログ機能の責務（v3.4 1.3節）
- 判断と報告の分離（v3.4 2.2節）

**参照すべき節:**
- v3.4 第2章: 設計思想（判断と報告の分離）
- v3.4 第4章: ログ出力形式
- v3.4 第5章: ログ記録の抑制と爆発対策
- v3.4 第7章: 実装時の注意事項

1.4 用語の定義
----------------------------------------------------------------

本仕様書で使用する用語を以下に定義する。

| 用語 | 定義 | 参照 |
|------|------|------|
| **パニック** | EAが正常系から逸脱した状態 | 第2章 |
| **スポット** | 特定条件下での詳細観測 | 第3章 |
| **RECOVERY状態** | 実行層で異常検出後、自動復旧を試みる状態。リトライ上限超過時はPANICへ遷移。 | 追従型OCO仕様書 v0.7 12.5節 |
| **即時記録** | メモリバッファに即座に蓄積すること（ファイル出力は5万件到達時またはFlush()呼び出し時） | 第2章 |
| **恒常運用** | 本番環境で常時有効化すること（スポットログでは禁止） | 第3章 |

================================================================================
第2章 パニックログ（200番台）
================================================================================

2.1 目的
----------------------------------------------------------------

パニックログは **「EAが正常系から逸脱した事実」** を
後から必ず説明できるようにするための最終記録である。

**重要:**

> **パニックログは「止めるためのログ」ではない。
止まる"理由"を残すためのログである。**

2.2 出力条件（原則）
----------------------------------------------------------------

以下のいずれかに該当した場合、必ず出力する。

1. 実行層でのリトライ上限超過
2. RECOVERY状態から復帰できなかった
3. 注文・ポジション整合性が取れない
4. 観測層が致命的エラーを返した
5. EA終了処理（OnDeinit）で異常が検出された

**注意:**
※ 判定ロジックは **ログ機能ではなく呼び出し側の責務**（v3.4 2.2節に準拠）

2.3 動作方針（確定）
----------------------------------------------------------------

### 2.3.1 ログ抑制

**抑制しない**
- 同一パニックログが連続しても全て記録
- 通常ログとは異なる方針

### 2.3.2 回数制限

**なし**
- 頻度ではなく「存在」が重要
- 1行でも欠ける方が致命的

### 2.3.3 記録タイミング（重要）

**通常ログと同じメモリバッファに蓄積:**
- 5万件到達時、または OnDeinit() でファイル出力
- パニックログだけ特別扱いはしない（設計思想の一貫性）

**ただし、推奨事項:**
- パニックログ出力後は可能な限り早期にFlush()を呼び出すことを推奨
- これにより、EA異常終了時でもログが残る確率が上がる

**実装例:**
```cpp
// パニックログ出力
data.AddLogEx(PANIC_RETRY_EXCEEDED, ERROR, 
              ticket, retry_count, max_retry, 0,
              "リトライ上限超過");

// 可能な限り即座にFlush（推奨）
data.FlushLog();
```

### 2.3.4 LogLevel

**INFO / WARN / ERROR を使用可能**
- FATAL は使用しない（EA停止を意味しないため）
- 致命的状況はLogID番号帯（200番台）で区別する（v3.4 4.3節と同様）

**理由:**
- LogLevelは「ログ内での重要度」を示す
- EA停止判断はログ機能の責務ではない

2.4 OnDeinitでの扱い
----------------------------------------------------------------

### 2.4.1 EA停止との関係

| 処理 | 方針 |
|------|------|
| EA停止判断 | ログ機能は関知しない（Strategy/Executionの責務） |
| 停止前 | パニックログを出力 |
| 停止後 | OnDeinit()で最終パニックログ出力可能 |

### 2.4.2 OnDeinit()での許容事項

OnDeinit()では以下を許容する：
- 残存注文・ポジションの記録
- 最終パニックログ出力
- 明示的なFlush()呼び出し

これらは「最後の悪あがき」として正当。
（追従型OCO仕様書 v0.7 12.5節と一致）

### 2.4.3 OnDeinit()での制約

**重要な制約:**
- OnDeinit()内でのトレード操作は成功保証なし
- ベストエフォートで実行
- 失敗した場合もPrint()等で記録を試みる
- AddLogEx()後は必ずFlush()を呼び出す（5万件待たない）

**理由:**
- OnDeinit()後はメモリがクリアされる
- バッファ内のログが失われる可能性
- 即時Flush()が必須

**実装例:**
```cpp
void OnDeinit(const int reason) {
    // 異常終了の記録
    if (reason != REASON_PROGRAM) {
        data.AddLogEx(PANIC_DEINIT_ABNORMAL, ERROR,
                      reason, 0, 0, 0,
                      "異常終了検出");
        
        // 必ず即座にFlush
        data.FlushLog();
    }
}
```

2.5 LogID方針（確定）
----------------------------------------------------------------

### 2.5.1 LogID割り当てルール

200番台の内部割り当て（層別）:

| 範囲 | 用途 | 備考 | 例 |
|------|------|------|-----|
| 200-209 | 共通パニック | 全層で使用可能 | RETRY_EXCEEDED, DEINIT_ABNORMAL |
| 210-219 | Strategy層パニック | 戦略固有の異常 | BOTH_FILLED, RECOVERY_FAILED |
| 220-229 | Decision層パニック | 判断固有の異常 | - |
| 230-239 | Execution層パニック | 実行固有の異常 | - |
| 240-249 | Observation層パニック | 観測固有の異常 | - |
| 250-299 | 予約 | 将来拡張 | - |

### 2.5.2 確定済みLogID（追従型OCO戦略との対応）

| LogID | 名称 | 概要 | 対応する異常ケース |
|-------|------|------|-------------------|
| 200 | PANIC_RETRY_EXCEEDED | リトライ上限超過 | ティック内リトライ最大回数超過（追従型OCO v0.7 12.5節） |
| 201 | PANIC_BOTH_FILLED | 両側約定検出 | OCO両側約定（追従型OCO v0.7 F章） |
| 202 | PANIC_INCONSISTENT | 注文／ポジション不整合 | データ不整合検出 |
| 203 | PANIC_RECOVERY_FAILED | Recovery処理失敗 | RECOVERY状態からの復帰失敗（追従型OCO v0.7 12.5節） |
| 204 | PANIC_DEINIT_ABNORMAL | 異常終了時の最終記録 | OnDeinit異常終了（reason != REASON_PROGRAM） |

**補足:**
- PANIC_ENTER（ドラフト版200）は削除（他のLogIDで代替）
- PANIC_DEINIT → PANIC_DEINIT_ABNORMAL に変更（明確化）
- 実装時に追加・変更可能

### 2.5.3 将来追加候補（実装時判断）

| LogID | 名称 | 用途 |
|-------|------|------|
| 205 | PANIC_MEMORY | メモリ不足検出 |
| 206 | PANIC_CONNECTION | 接続断検出 |
| 207 | PANIC_INVALID_STATE | 不正な状態遷移 |

================================================================================
第3章 スポットログ（300番台）
================================================================================

3.1 目的
----------------------------------------------------------------

スポットログは **「ある瞬間の詳細観測」** を行うためのログである。

**用途:**
- デバッグ
- テスト検証
- 実運用中の一時調査

**重要:** 恒常運用は想定しない。

3.2 出力条件
----------------------------------------------------------------

### 3.2.1 有効化条件

**明示的に有効化された場合のみ出力:**
- 外部パラメータで有効化（推奨）
- または コンパイルフラグで制御

**推奨方式（確定）:**

**方式A: 外部パラメータ（推奨）**
```cpp
input bool InpEnableSpotLog = false;
```
- 実行中に変更不可
- 再起動で有効化
- 運用者が制御可能

**方式B: コンパイルフラグ（開発時のみ）**
```cpp
#define ENABLE_SPOT_LOG
```
- 本番環境では削除
- 開発者のみが制御

**採用: 方式A（運用者が制御可能）**

### 3.2.2 出力頻度

**通常ログと同じ原則を適用:**
- 状態変化時のみ出力することを推奨（v3.4 2.3節）

**ただし、デバッグ目的での例外:**
- 一時的に頻繁な出力を行うことは許容
- やむを得ず毎Tick出力する場合は以下を遵守:
  - **テスト環境のみで使用**
  - **短時間のみ有効化**
  - **本番環境では必ず無効化**

**重要な注意:**
- 毎Tick出力を有効化すると月間約210万行発生（月間Tick数 v3.4 6.1節）
- ファイルサイズ: 約240MB/月（115バイト/行 × 210万行）
- 5万件で自動Flush → 約6時間で1回出力

**推奨運用:**
- テスト完了後は必ず無効化
- 本番環境では InpEnableSpotLog = false を厳守

3.3 動作方針
----------------------------------------------------------------

### 3.3.1 ログ抑制

**行わない**
- スポットログは観測が目的
- 抑制すると観測できない

### 3.3.2 件数制限

**行わない**
- 観測目的のため制限しない
- ただし、メモリ爆発リスクに注意（上記3.2.2参照）

### 3.3.3 Flushルール

**通常ログと共通**
- 5万件で自動Flush（v3.4 5.2節）
- OnDeinit()でFlush

3.4 LogID方針
----------------------------------------------------------------

### 3.4.1 LogID割り当てルール

300番台の内部割り当て（層別）:

| 範囲 | 用途 | 備考 |
|------|------|------|
| 300-309 | 共通スポット | 全層で使用可能 |
| 310-319 | Strategy層スポット | 戦略固有の観測 |
| 320-329 | Decision層スポット | 判断固有の観測 |
| 330-339 | Execution層スポット | 実行固有の観測 |
| 340-349 | Observation層スポット | 観測固有の観測 |
| 350-399 | 予約 | 将来拡張 |

### 3.4.2 LogID例（用途別）

**処理経路の追跡:**

| LogID | 名称 | 用途 |
|-------|------|------|
| 300 | SPOT_TRACE | 処理経路の通過記録 |

**状態観測:**

| LogID | 名称 | 用途 |
|-------|------|------|
| 301 | SPOT_STATE_DUMP | STATE遷移前後の状態スナップショット |
| 302 | SPOT_SPREAD | スプレッド詳細観測 |
| 303 | SPOT_PRICE | 価格変動詳細観測 |

**変数監視:**

| LogID | 名称 | 用途 |
|-------|------|------|
| 304 | SPOT_COUNTER | カウンタ値監視 |
| 305 | SPOT_FLAG | フラグ状態監視 |

**使用例:**
```cpp
// デバッグ時のみ有効化
if (InpEnableSpotLog) {
    data.AddLogEx(SPOT_SPREAD, INFO, 
                  current_spread, threshold, 0, 1,
                  "スプレッド異常検証");
}
```

**注意:**
- これらは例示であり、実装時に自由に追加可能
- 本番環境では必ず無効化

================================================================================
第4章 通常状態ログとの関係
================================================================================

4.1 役割分担（最重要）
----------------------------------------------------------------

### 4.1.1 原則

各ログ種別は明確に役割が異なる。混同してはならない。

| 種別 | 役割 | 例 |
|------|------|------|
| 通常状態ログ | 「何が起きたか」 | OCO配置、MODIFY成功、約定検出 |
| パニックログ | 「なぜ破綻したか」 | 両側約定、リトライ超過、不整合検出 |
| スポットログ | 「その瞬間に何が見えていたか」 | 変数値、内部状態、処理経路 |

### 4.1.2 禁止事項（具体例）

**❌ 通常ログでパニックを代替:**
- 悪い例: LOG_ID_MODIFY_FAILを10回連続で記録してパニックを表現
- 正しい例: PANIC_RETRY_EXCEEDEDを使用

**❌ パニックログで通常ログを代替:**
- 悪い例: PANIC_NORMAL_OPERATIONのような通常動作のパニックログ
- 正しい例: 通常ログを使用

**❌ スポットログを恒常運用:**
- 悪い例: 毎Tick変数値を記録し続ける（本番環境で有効化）
- 正しい例: テスト時のみ有効化、本番では無効化

### 4.1.3 判断基準

**ログ種別の選択基準:**

1. **正常系の状態変化** → 通常ログ（100番台）
2. **異常系の破綻** → パニックログ（200番台）
3. **一時的な観測** → スポットログ（300番台）

迷った場合は通常ログを選択。
パニックログは「最終手段」として扱う。

================================================================================
第5章 実装時の注意事項
================================================================================

5.1 ログ独立性
----------------------------------------------------------------

**ログ機能は判断を持たない（v3.4 1.3節）**
- if文の条件分岐は呼び出し側で完結させる
- ログ機能は受け取ったログをそのまま記録

**例（正しい実装）:**
```cpp
// 呼び出し側で判断
if (retry_count > max_retry) {
    // パニック判定は呼び出し側の責務
    data.AddLogEx(PANIC_RETRY_EXCEEDED, ERROR,
                  ticket, retry_count, max_retry, 0,
                  "リトライ上限超過");
}
```

**例（誤った実装）:**
```cpp
// ログ機能内で判断（禁止）
void AddLogEx(...) {
    if (log_id == PANIC_RETRY_EXCEEDED) {
        // ❌ ログ機能内で特別処理（禁止）
        FlushLog();
    }
}
```

5.2 パフォーマンス上の注意
----------------------------------------------------------------

**文字列生成は記録確定後のみ行う（v3.4 7.4節）**
```cpp
// 良い例
if (InpEnableSpotLog) {
    string msg = StringFormat("変数値: %d", value);
    data.AddLogEx(SPOT_VALUE, INFO, value, 0, 0, 0, msg);
}

// 悪い例
string msg = StringFormat("変数値: %d", value); // 常に実行される
if (InpEnableSpotLog) {
    data.AddLogEx(SPOT_VALUE, INFO, value, 0, 0, 0, msg);
}
```

5.3 CSV出力の注意事項
----------------------------------------------------------------

**RFC4180準拠（v3.4 7.3節）**
- Message欄のみエスケープ処理を実施
- カンマ、ダブルクォート、改行文字をエスケープ

5.4 static変数の使用禁止
----------------------------------------------------------------

**static ローカル変数の使用禁止（v3.4 7.2節）**
- 理由1: 複数インスタンス間で状態が共有される
- 理由2: テスト時の初期化が困難
- 理由3: スレッドセーフでない
- 代替: クラスメンバ変数を使用

================================================================================
第6章 LogID一元管理
================================================================================

6.1 管理方法
----------------------------------------------------------------

**全LogIDはCLA_Common.mqhの enum ENUM_LOG_ID で一元管理**
- 新規LogID追加時は必ずこのenumに追加
- これにより番号重複を防止（v3.4 3.6節と同様）

**例:**
```cpp
// CLA_Common.mqh
enum ENUM_LOG_ID {
    // 100番台: 通常状態ログ
    LOG_ID_OCO_PLACE = 100,
    LOG_ID_MODIFY_OK = 102,
    // ...
    
    // 200番台: パニックログ
    LOG_ID_PANIC_RETRY_EXCEEDED = 200,
    LOG_ID_PANIC_BOTH_FILLED = 201,
    LOG_ID_PANIC_INCONSISTENT = 202,
    LOG_ID_PANIC_RECOVERY_FAILED = 203,
    LOG_ID_PANIC_DEINIT_ABNORMAL = 204,
    
    // 300番台: スポットログ
    LOG_ID_SPOT_TRACE = 300,
    LOG_ID_SPOT_STATE_DUMP = 301,
    LOG_ID_SPOT_SPREAD = 302,
    LOG_ID_SPOT_PRICE = 303,
    LOG_ID_SPOT_COUNTER = 304,
    LOG_ID_SPOT_FLAG = 305
};
```

6.2 番号体系の遵守
----------------------------------------------------------------

**番号帯の意味は固定（v3.4 3.7節）**
- 100番台: 通常状態ログ
- 200番台: パニックログ
- 300番台: スポットログ
- 番号帯を跨ぐ意味の混在は禁止

================================================================================
第7章 記録量見積もり
================================================================================

7.1 見積もりの前提条件
----------------------------------------------------------------

- 対象: パニックログ + スポットログ
- 記録方式: パニック（抑制なし）、スポット（条件付き）
- テスト実績: 約2,100,000 Tick / 月、約639トレード / 月（v3.4 6.1節）

7.2 パニックログの見積もり
----------------------------------------------------------------

### 7.2.1 想定頻度

- **正常運用時**: 月0回（理想）
- **異常発生時**: 月0-5回
- **1回あたり**: 1-3行

### 7.2.2 月間想定

```
最大5回 × 3行 = 15行 / 月
15行 × 115バイト = 約1.7KB / 月
```

### 7.2.3 容量影響

**無視できるレベル**
- 通常ログ（月間15,000行）に比べて0.1%以下
- パフォーマンス影響なし

7.3 スポットログの見積もり
----------------------------------------------------------------

### 7.3.1 想定頻度

- **本番環境**: 0回（無効化）
- **テスト環境（条件付き）**: 月100-1,000行
- **テスト環境（毎Tick）**: 月2,100,000行（危険）

### 7.3.2 月間容量

**条件付き有効化:**
```
1,000行 × 115バイト = 約115KB / 月
```

**毎Tick有効化（危険）:**
```
2,100,000行 × 115バイト = 約240MB / 月
```

### 7.3.3 推奨運用

- テスト時のみ有効化
- 本番環境では必ず無効化
- 毎Tick出力は短時間のみ

7.4 結論
----------------------------------------------------------------

- パニックログ: 容量影響なし
- スポットログ（条件付き）: 容量影響なし
- スポットログ（毎Tick）: 要注意（本番禁止）

================================================================================
第8章 測定方法とテスト観点
================================================================================

8.1 完成条件（定義）
----------------------------------------------------------------

以下をすべて満たした時点で **実装完了（DONE）** とする。

### 8.1.1 条件1: パニックログが「必ず残る」

**測定方法:**
- 異常ケースをシミュレート（両側約定、リトライ超過、OnDeinit異常終了）
- CSV内のLogIDを確認

**基準:**
- 全異常ケースでパニックログ（200番台）が出力される
- OnDeinit時のFlush()が実行されている（タイムスタンプ確認）

### 8.1.2 条件2: スポットログが「邪魔をしない」

**測定方法:**
- スポットログ有効/無効でバックテスト実施
- トレード結果を比較

**基準:**
- トレード結果が完全に一致（回数、損益、タイミング）
- ログ有無でEAの挙動が変わらない

### 8.1.3 条件3: 通常ログの設計を汚染しない

**測定方法:**
- CSV内のLogIDを確認
- 番号帯の分離を確認

**基準:**
- 100番台: 通常状態ログのみ
- 200番台: パニックログのみ
- 300番台: スポットログのみ
- 番号帯が混在していない

### 8.1.4 条件4: ログを理由にEAの挙動が変わらない

**測定方法:**
- 全ログ無効化でバックテスト実施
- トレード結果を比較

**基準:**
- トレード結果が完全に一致
- ログ機能の独立性が確保されている

8.2 検証方法（詳細）
----------------------------------------------------------------

### 8.2.1 パニックログのテスト

**テストケース1: 両側約定**
```
1. 意図的に両側約定を発生させる
2. CSV内にPANIC_BOTH_FILLED（201）が存在するか確認
3. Param1-4に適切な情報が記録されているか確認
```

**テストケース2: リトライ超過**
```
1. 意図的にリトライ上限を超えさせる
2. CSV内にPANIC_RETRY_EXCEEDED（200）が存在するか確認
3. Param2（retry_count）がmax_retryを超えているか確認
```

**テストケース3: OnDeinit異常終了**
```
1. EA異常終了をシミュレート（reason != REASON_PROGRAM）
2. CSV内にPANIC_DEINIT_ABNORMAL（204）が存在するか確認
3. ファイル出力が完了しているか確認（Flush実行）
```

### 8.2.2 スポットログのテスト

**テストケース1: 有効/無効の切替**
```
1. InpEnableSpotLog=true で起動
2. 300番台ログが出力されるか確認
3. InpEnableSpotLog=false で起動
4. 300番台ログが一切出ないか確認
```

**テストケース2: トレード結果の一致**
```
1. スポットログ有効でバックテスト（100トレード）
2. スポットログ無効でバックテスト（100トレード）
3. トレード結果（回数、損益、タイミング）が完全一致するか確認
```

### 8.2.3 パフォーマンステスト

**測定項目:**
- OnTick処理時間（ログ有無での比較）
- メモリ使用量（ログ有無での比較）
- ファイルサイズ（1か月テスト後）

**合格基準:**
- OnTick処理時間の増加: 5%以内
- メモリ使用量の増加: 10MB以内
- ファイルサイズ: 5MB以内（パニック+スポット合計、スポット無効時）

8.3 CSV検証スクリプト（任意）
----------------------------------------------------------------

**目的:**
- CSVの番号帯分離を自動検証
- LogID重複を検出

**検証項目:**
```python
# aegis_csv_validator.py（例）
def validate_log_id_ranges(csv_file):
    """LogIDの番号帯を検証"""
    # 100番台: 通常ログのみ
    # 200番台: パニックログのみ
    # 300番台: スポットログのみ
    pass

def detect_duplicate_log_id(csv_file):
    """LogID重複を検出"""
    pass
```

**注意:**
- これは任意の追加機能
- 手動検証（Excel）で十分

================================================================================
第9章 FAQ（よくある質問）
================================================================================

9.1 パニックログ関連
----------------------------------------------------------------

**Q1: パニックログが出たらEAは止まるのか？**

A1: いいえ。EA停止はStrategy/Executionの判断。ログは記録のみ。
    パニックログは「止まる理由を残すため」であり、「止めるため」ではない。

**Q2: PANIC_BOTH_FILLEDが出た後の処理は？**

A2: 追従型OCO仕様書 v0.7（F章）参照。
    遠い方をクローズ → STATE_COMPLETED → 別Strategyへ引き継ぎ。
    パニックログはその記録のみ。

**Q3: OnDeinit時にパニックログが残らない場合は？**

A3: Flush()呼び出しを確認。5万件待ちは不可。
    OnDeinit内で必ずFlush()を明示的に呼び出すこと。

**Q4: パニックログとERRORレベルの違いは？**

A4: ERRORは通常ログ内の重要度（LogLevel）。
    パニックは番号帯（200番台）で区別。
    致命的状況はLogID番号帯で判断する（v3.4 4.3節参照）。

9.2 スポットログ関連
----------------------------------------------------------------

**Q5: スポットログを本番環境で有効化してもよいか？**

A5: 非推奨。毎Tick出力すると月間210万行発生。
    条件付き出力でも、本番環境では無効化を推奨。

**Q6: スポットログの有効化を忘れたらどうなるか？**

A6: 300番台ログが一切出ない。
    テスト前に InpEnableSpotLog=true を確認すること。

**Q7: スポットログで毎Tick出力は禁止？**

A7: 推奨しないが、テスト環境での短時間使用は許容。
    ただし、本番環境では必ず無効化すること。

9.3 通常ログとの関係
----------------------------------------------------------------

**Q8: 通常ログとパニックログの境界は？**

A8: 通常ログは「正常系の状態変化」。
    パニックログは「異常系の破綻」。
    
    例: MODIFY失敗の場合
    - 1-2回の失敗 → 通常ログ（LOG_ID_MODIFY_FAIL）
    - 10回連続失敗 → パニックログ（PANIC_RETRY_EXCEEDED）
    
    迷ったら通常ログを選択。

**Q9: ログ種別を変更したい場合は？**

A9: LogIDを変更する（100→200等）。
    ただし、ENUM_LOG_IDも更新すること（番号重複防止）。

================================================================================
第10章 まとめ
================================================================================

10.1 完成定義
----------------------------------------------------------------

以下をすべて満たした時点で **実装完了（DONE）** とする。

1. パニックログが「必ず残る」（測定可能）
2. スポットログが「邪魔をしない」（測定可能）
3. 通常ログの設計を汚染しない（番号帯分離）
4. ログを理由にEAの挙動が変わらない（独立性確保）

10.2 価値と最終宣言
----------------------------------------------------------------

本仕様により、Aegis は以下を獲得する。

- **パニックログ**: 「なぜ破綻したか」を必ず説明できる
- **スポットログ**: 「その瞬間に何が見えていたか」を記録できる
- **3種のログ**: 補完し合い、全体像を明らかにする

**最終宣言:**

> **パニックログとスポットログは
Aegisを強くするためではなく、
壊れなかった理由を残すために存在する**

10.3 次実装への引き渡し事項
----------------------------------------------------------------

次実装に引き渡すもの：

- 200番台/300番台のLogID定義
- パニック/スポットログの設計思想
- 通常ログとの役割分担
- 測定方法とテスト観点
- 実運用で得られた知見

================================================================================
パニックログ／スポットログ 実装仕様書 v1.1 完（最終版）
================================================================================



