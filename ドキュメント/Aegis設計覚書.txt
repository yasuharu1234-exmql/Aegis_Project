================================================================================
フェーズB実装メモ
仕様書反映候補事項
================================================================================

作成日: 2026-01-05
作成者: Claude（実装担当）
対象: 追従型OCO観測層・判断層の実装

================================================================================
1. CLA_Dataへの追加事項
================================================================================

1.1 メンバ変数
----------------------------------------------------------------

追加したメンバ変数:
```cpp
// ========== フェーズB追加: 追従型OCO観測データ ==========
bool m_obs_entry_clear;  // エントリー可能状態（約定前注文・ポジションなし）
```

初期化:
```cpp
m_obs_entry_clear = false;  // フェーズB: 追従型OCO観測初期化
```

1.2 アクセサメソッド
----------------------------------------------------------------

追加したメソッド:

**SetObs_EntryClear(bool is_clear)**
- 役割: エントリー可能状態を設定
- 引数: true=エントリー可能, false=障害あり
- 呼び出し元: 観測層（CObservationOCOState）

**GetObs_EntryClear()**
- 役割: エントリー可能状態を取得
- 戻り値: true=エントリー可能, false=障害あり
- 呼び出し元: 判断層（CDecisionOCOFollow）

1.3 命名規則
----------------------------------------------------------------

**提案: 観測データの命名規則を統一すべき**

現状:
- RSI値: SetRSIValue() / GetRSIValue()
- エントリー可能: SetObs_EntryClear() / GetObs_EntryClear()

→ 命名が不統一（RSI_Valueにはプレフィックスなし）

**推奨案:**
- 観測データには「Obs_」プレフィックスを統一
- 例: SetObs_RSI() / GetObs_RSI()
- 例: SetObs_EntryClear() / GetObs_EntryClear()

**ただし:**
- 既存のSetRSIValue()は変更しない（後方互換）
- 新規追加時にのみ統一規則を適用

================================================================================
2. CObservationOCOState仕様
================================================================================

2.1 クラス概要
----------------------------------------------------------------

**ファイル名:** CObservationOCOState.mqh
**レイヤー:** Observation
**目的:** 追従型OCO戦略用の状態観測

2.2 観測する事実
----------------------------------------------------------------

**1. 約定前注文の有無**
- 対象: BuyStop, SellStop
- チェック: マジックナンバー、シンボル

**2. ポジションの有無**
- 対象: Buy, Sell（約定済み）
- チェック: マジックナンバー、シンボル

**3. エントリー可能判定**
- 両方なし → true（エントリー可能）
- どちらか存在 → false（エントリー不可）

2.3 設計思想
----------------------------------------------------------------

**重要:** 判断はしない
- ○ 事実を観測してCLA_Dataに格納
- × エントリーすべきか判断（これは判断層の役割）

2.4 実装上の注意
----------------------------------------------------------------

**exMQL.OrdersTotal()の使用**
- MT4/MT5互換のため、EXMQL経由でのみアクセス
- OrderSelect()も同様

**マジックナンバーチェック**
- コンストラクタで指定されたマジックナンバーのみを対象
- 他のEA・手動注文は無視

================================================================================
3. CDecisionOCOFollow仕様
================================================================================

3.1 クラス概要
----------------------------------------------------------------

**ファイル名:** CDecisionOCOFollow.mqh
**レイヤー:** Decision
**目的:** 追従型OCO戦略の判断層（フェーズB: 最小実装）

3.2 フェーズB実装内容
----------------------------------------------------------------

**実装済み:**
- CLA_Dataから観測結果を取得
- 受信できることを確認

**未実装（フェーズC以降）:**
- エントリー可否の最終判断
- Action生成
- Decision Arbiterとの連携
- ログ出力

3.3 設計思想
----------------------------------------------------------------

**CLA_Data経由のみ**
- ○ data.GetObs_EntryClear()で取得
- × 観測層インスタンスへの直接参照

**層の分離**
- 観測層と判断層は直接参照しない
- CLA_Dataが唯一の接続点

3.4 フェーズC以降の実装予定
----------------------------------------------------------------

**Action生成:**
```cpp
// 疑似コード
if(entry_clear) {
    // OCO配置のAction生成
    // Decision Arbiterに登録
}
```

**Decision Arbiter:**
- 複数の判断ロジックを調停
- 必ず1つのActionに確定
- 実行層への橋渡し

================================================================================
4. 既存コードとの関係
================================================================================

4.1 既存実装を温存
----------------------------------------------------------------

**温存したクラス:**
- CObservationRSI（既存）
- CDecisionRSI_Simple（既存）

**理由:**
- 後方互換性維持
- 既存の観測層→判断層の直接参照方式も動作継続

4.2 新旧の共存
----------------------------------------------------------------

**観測層 → 判断層のデータ受け渡し方式:**

**旧方式（B方式）:**
```cpp
CDecisionRSI_Simple(CObservationRSI* obs) {
    m_rsi_observer = obs;
}
double rsi = m_rsi_observer->GetLastValue();
```

**新方式（A方式・フェーズB確立）:**
```cpp
// 観測層
data.SetObs_EntryClear(true);

// 判断層
bool clear = data.GetObs_EntryClear();
```

**結論:**
- 両方式が共存
- 新規実装は新方式（A方式）を採用
- 既存実装は旧方式のまま

================================================================================
5. 今後の改善候補
================================================================================

5.1 命名規則の統一
----------------------------------------------------------------

**現状の課題:**
- 観測データのアクセサが不統一
- SetRSIValue() vs SetObs_EntryClear()

**改善案:**
- 「Obs_」プレフィックスを統一
- 新規追加時のみ適用（既存は変更しない）

5.2 観測データ構造化
----------------------------------------------------------------

**現状:**
- 個別のメンバ変数で管理
- m_rsi_value, m_obs_entry_clear, ...

**将来案:**
```cpp
struct ObservationData {
    double rsi_value;
    bool entry_clear;
    // ...
};
```

**ただし:**
- フェーズBでは不要
- 複雑化を避けるため、現状維持

5.3 観測層の拡張
----------------------------------------------------------------

**フェーズC以降の拡張候補:**
- 約定前注文の詳細（価格、ロット等）
- ポジション状態の詳細（利益、損失等）
- スプレッド観測
- 経済指標観測

================================================================================
6. PMへの質問・確認事項
================================================================================

6.1 命名規則について
----------------------------------------------------------------

**質問:**
観測データのアクセサに「Obs_」プレフィックスを統一すべきか？

**現状:**
- SetRSIValue() （プレフィックスなし）
- SetObs_EntryClear() （プレフィックスあり）

**選択肢:**
- A: 新規追加時のみ「Obs_」を付ける（今回採用）
- B: 既存も含めて全て「Obs_」に統一（後方互換破壊）
- C: 統一しない（現状維持）

**推奨:**
選択肢A（後方互換維持）

6.2 フェーズBの完了条件確認
----------------------------------------------------------------

**質問:**
以下の実装でフェーズB完了と判定してよいか？

**実装内容:**
- ✅ CLA_Dataに観測結果の格納/取得を追加
- ✅ CObservationOCOState（観測層）でCLA_Dataに格納
- ✅ CDecisionOCOFollow（判断層）でCLA_Dataから取得
- ✅ コンパイルエラー/ワーニング: 0（予定）

**未実装（フェーズC以降）:**
- ❌ Action生成
- ❌ Decision Arbiter
- ❌ ログ出力

================================================================================
終
================================================================================

================================================================================
Aegis「N Tick観測設計」仕様書反映候補
================================================================================

[Claude]

**セルフチェック：**
- AI名：Claude
- 役割：実装担当

---

## 📝 Aegis「N Tick観測設計」仕様書反映候補

**作成日:** 2026年1月8日  
**作成者:** Claude（実装担当）  
**文書種別:** 設計整理メモ（仕様書反映候補）  
**目的:** 観測周期設計の正当性と効果の文書化

---

## 1. 観測層（Observation）の責務再定義

### 1-1. なぜ毎Tick入力を受け取るのか

**原則:**
市場の事実は毎Tick発生する。観測層は「見逃さない」ことが第一の責務。

**理由:**
- 市場の価格変動は連続的に発生する
- どのTickが重要かは事前に判断できない
- 観測層は「判断の材料」を提供する役割であり、判断自体は行わない

**設計上の位置づけ:**
観測層は「センサー」である。センサーは常時稼働し、データを蓄積する。

---

### 1-2. N Tickを1ウィンドウとする意味

**背景:**
毎Tickの微小な価格変動をそのまま判断層に渡すと、以下の問題が発生する：
- 市場ノイズを増幅する
- 計算負荷が無駄に高い
- 人間が「フラフラしている」と認識する

**解決策:**
N Tickを1単位として、その期間内の価格情報を「要約」する。

**要約の意味:**
- 高値：期間内で最も高い価格
- 安値：期間内で最も低い価格
- 始値：期間開始時の価格
- 終値：期間終了時の価格

これらは「N Tick期間の市場特性」を代表する指標となる。

**N の決定方針:**
- 小さすぎる → ノイズを吸収できない
- 大きすぎる → 市場変化への追従が遅れる
- N = 50 は初期値（バックテストで調整可能）
- **重要:** N は設定値であり、ハードコード禁止

---

### 1-3. ウィンドウ内で保持すべき情報

#### 必須項目
- **高値（WindowHigh）**: ウィンドウ内の最高価格
- **安値（WindowLow）**: ウィンドウ内の最低価格

この2つだけで以下が可能：
- 追従型戦略（高値・安値を基準に注文配置）
- ブレイクアウト戦略（高値・安値の突破判定）
- レンジ判定（高値・安値の差でレンジ幅計算）

#### 拡張候補
- **始値（WindowOpen）**: ウィンドウ開始時の価格
- **終値（WindowClose）**: ウィンドウ終了時の価格
- **中心価格（WindowMid）**: (高値 + 安値) / 2
- **レンジ幅（WindowRange）**: 高値 - 安値

**拡張の意義:**
- より高度な戦略に対応可能
- 市場の方向性やボラティリティを判断材料に追加
- 判断層が「どの値を使うか」を選択できる柔軟性

#### デバッグ用情報
- **ウィンドウID**: 何番目のウィンドウか
- **Tick数**: 現在ウィンドウ内で何Tick目か

**保持しないもの:**
- 全Tickの価格履歴（メモリ効率）
- 判断に必要ない詳細情報

---

### 1-4. 「今が判断可能タイミングか」を通知する仕組み

**概念:**
観測層は「観測結果が確定したタイミング」を判断層に通知する必要がある。

**通知方法:**
フラグ型の状態変数（例: Obs_Updated）を使用。

**動作:**
- N Tick目（ウィンドウ終了時）: Obs_Updated = true
- それ以外のTick: Obs_Updated = false

**意義:**
- 判断層は「今、判断すべきか」を自律的に判断できる
- 観測層は「判断しろ」とは言わない（責務分離）
- 観測層は「判断材料が揃った」とだけ通知する

**設計上の重要性:**
これにより、判断層は「待つ」ことができる。
「待つ」は「サボり」ではなく、「安定した判断材料を得るための設計」である。

---

## 2. 判断層（Decision）の振る舞い整理

### 2-1. 観測結果 → 状態（State）への変換

**判断層の本質的役割:**
「観測された事実」を「どう行動すべきか」に変換すること。

**変換の例:**
```
観測: ウィンドウ高値 = 150.50
     ウィンドウ安値 = 150.00
     
判断: 現在の注文を高値+50pt、安値-50ptに配置すべき
     
結果: ACTION_OCO_MODIFY を生成
```

**重要な点:**
判断層は「観測層が確定させた値」だけを使う。
生のask/bidを直接参照しない。

---

### 2-2. 毎Tick即応が必要な判断と、N Tick確定後のみ行う判断

#### 毎Tick即応が必要な判断
**例: ポジション検出によるCANCEL**
- 状況: ポジションが約定した
- 必要性: 即座に残った注文をキャンセル
- 理由: ウィンドウ終了を待つと損失拡大の可能性

**観測:**
- CObservationOCOStateは毎Tick動作
- ポジション検出は即座に行う

**判断:**
- has_position == true なら即座にACTION_OCO_CANCEL

#### N Tick確定後のみ行う判断
**例: OCO注文の追従**
- 状況: 市場価格が変動している
- 必要性: 安定した基準で追従したい
- 理由: 毎Tickの微小変動に反応すると不安定

**観測:**
- N Tickごとに高値・安値を確定

**判断:**
- Obs_Updated == true のときだけACTION_OCO_MODIFY

---

### 2-3. Obs_Updated的フラグの役割

**概念:**
「判断材料が新しくなった」という通知。

**判断層の動作:**
```
毎Tick呼ばれる

if (Obs_Updated == false)
    → ACTION_NONE を返す（判断材料が古いまま）

if (Obs_Updated == true)
    → 通常の判断ロジックを実行
    → 適切なActionを生成
```

**設計上の効果:**
- 判断層は「無駄な判断」をしない
- 判断層は「判断タイミング」を観測層から受け取る
- 判断層のロジック本体は変更不要（1行のif文追加のみ）

**重要な洞察:**
判断層が「待つ」のは、観測層が「まだ確定していない」と教えてくれるから。
これは設計の分離が正しく機能している証拠。

---

## 3. 実行層（Execution）が一切変わらない理由

### 3-1. Action頻度が変わっても設計が崩れない理由

**実行層の責務:**
「Actionを受け取ったら実行する」だけ。

**Actionの頻度:**
- N Tick設計前: 毎Tick ACTION_OCO_MODIFY が来る
- N Tick設計後: N Tickに1回 ACTION_OCO_MODIFY が来る

**実行層から見た変化:**
- Actionの「内容」は同じ
- Actionの「頻度」だけが変わった

**なぜ設計が崩れないか:**
実行層は「いつActionが来るか」を知る必要がない。
来たら実行する、来なければ何もしない。これだけ。

**設計の美しさ:**
```
観測層: 観測周期を変更
判断層: 判断タイミングを変更
実行層: 何も変わらない
```

これが「責務分離」の価値。

---

### 3-2. ACTION_NONEが大量に流れても問題ない理由

**N Tick設計後の典型的な流れ:**
```
Tick 1-49: ACTION_NONE × 49回
Tick 50:   ACTION_OCO_MODIFY × 1回
```

**ACTION_NONEの意味:**
「今は何もしない」という正当な判断結果。

**実行層の処理:**
```
if (action.type == ACTION_NONE)
    return true;  // 何もせず成功
```

**コスト:**
- 計算コスト: ほぼゼロ（単純な分岐）
- メモリコスト: ゼロ（何も実行しない）
- 通信コスト: ゼロ（OrderSendしない）

**設計上の意義:**
ACTION_NONEは「無駄」ではなく、「判断の結果」である。
「何もしないことを選んだ」という意思決定の記録。

---

## 4. フラつき問題に対する設計的検証視点

### 4-1. 「もし別原因があるなら、N Tick化しても現象は残る」

**検証の考え方:**
N Tick設計は「頻度」の問題を解決する。

**もし頻度以外に原因があれば:**
- N Tick化してもフラつきは残る
- 例: 計算式のバグ、基準価格の誤り、等

**N Tick化後にフラつきが消えれば:**
- 原因は「頻度」だったと確定
- 計算式は正しかったことの証明

**設計的価値:**
N Tick設計は「解決策」であると同時に「原因特定装置」でもある。

---

### 4-2. N Tick設計が原因切り分け装置として機能する理由

**検証可能な仮説:**
1. 頻度が原因 → N Tick化で解決
2. 計算式が原因 → N Tick化しても残る
3. 基準価格が原因 → N Tick化しても残る

**実験設計として優秀な点:**
- 変更箇所が明確（観測周期のみ）
- 他の要素を変更しない
- 結果が明確（フラつくか、しないか）

**科学的手法:**
これは「制御された実験」である。
1変数だけを変更し、結果を観察する。

---

### 4-3. 設計ミスと市場ノイズを分離できる理由

**問題の切り分け:**

#### ケースA: N Tick化でフラつきが消えた
- 結論: 市場ノイズが原因だった
- 設計: 正しい（計算式は合っていた）
- 解決: 観測周期の最適化で対応

#### ケースB: N Tick化してもフラつきが残る
- 結論: 設計ミスが原因
- 候補: 計算式、基準価格、型精度、等
- 対応: ロジックの再検証

**重要な洞察:**
N Tick設計を実装する前に、「もし消えなかったら何が原因か」を考えておく。
これが設計者の仕事。

---

## 5. 全体設計への効果

### 5-1. なぜ毎Tickで判断しないのか

**答え:**
毎Tickの判断は「市場ノイズを増幅する」から。

**詳細:**
- 市場価格は毎Tick微小に変動する
- その変動の多くは「ノイズ」（意味のない揺らぎ）
- ノイズに反応して毎Tick行動すると、結果もノイズになる

**N Tick設計の効果:**
- N Tick分のノイズを「平滑化」する
- 意味のある価格変動だけを捉える
- 人間が「安定している」と認識できる

---

### 5-2. なぜ観測と判断の周期を分けるのか

**答え:**
観測と判断は「異なる責務」だから。

**観測の責務:**
- 事実を記録する
- 見逃さない
- 判断しない

**判断の責務:**
- 事実を解釈する
- 行動を決める
- 実行しない

**周期を分ける意義:**
- 観測: 毎Tick（高頻度）
- 判断: N Tickごと（低頻度）
- これにより、「見逃さず、騒がない」が実現する

---

### 5-3. N Tickという設計がAegis全体にどう効くのか

**効果①: ノイズ耐性**
- 微小な価格変動を吸収
- 安定した判断材料を提供

**効果②: 計算効率**
- 判断・実行が1/N に削減
- OrderSend回数が激減

**効果③: 説明可能性**
- 「N Tickの高値を基準に追従」と言える
- ログが人間に理解しやすい

**効果④: 保守性**
- 観測周期を変更してもロジックは変わらない
- N は設定値として調整可能

**効果⑤: テスト容易性**
- N = 1 にすれば従来動作（毎Tick判断）
- N を変えて比較実験が可能

---

## 6. 実装への示唆

**観測層への追加:**
- N Tickカウンタ
- ウィンドウ内の高値・安値蓄積
- Obs_Updated フラグ管理

**判断層への追加:**
- 冒頭に Obs_Updated チェック（1行）
- 基準価格の参照先変更

**実行層:**
- 変更なし

**設定パラメータ:**
- WindowSize（N）: デフォルト50、調整可能

---

## 7. 今後の拡張性

**N Tickウィンドウは拡張可能:**
- 複数の時間軸（10Tick、50Tick、200Tick）を同時観測
- 短期・中期・長期のトレンド判定
- マルチタイムフレーム分析

**判断層の拡張:**
- ウィンドウ内の高値・安値だけでなく
- ボラティリティ、方向性、等も判断材料に

**この設計は「スケーラブル」:**
- 1つのウィンドウで動作確認
- 複数ウィンドウへの拡張は容易

---

**以上、2026年1月8日 設計整理完了**

**この文書は将来、Aegis仕様書に反映可能な形式で作成されています。**

---

**Claude（実装担当）**



================================================================================
Aegis_設計覚書_モジュール責務と正当性
================================================================================
いいですね、それ。
これはそのままAegisの思想を一段引き上げる内容なので、
「覚書（設計メモ）」として残しておく価値があります。

では、仕様書に組み込みやすい形で、
まずは「覚書案」を作りましょう。
（あとで正式仕様に昇格させやすい構成にしてあります）


---

📌 Aegis 設計覚書

― モジュール間データ受け渡しと正当性保証について ―

1. 基本原則

Aegisにおけるすべての処理は、以下の基本原則に従う。

> 入力 → 処理 → 出力



各モジュールは独立した機能単位であり、
その出力は、必ず別モジュールの入力となる。


---

2. 出力データに対する責務（出力側）

モジュールが何らかのデータを出力する場合、
出力側は以下を保証しなければならない。

未初期化値ではないこと

数値として破綻していないこと（NaN / INF 等でない）

明らかに不正な範囲にないこと


これは論理的な正しさの保証ではなく、形式的・構造的な保証である。

> 出力側の責務は
「このデータは“形として成立している”」ことの保証に留める




---

3. 入力データに対する責務（入力側）

データを受け取る側のモジュールは、

自身が前提としている条件

自身が処理可能な範囲


に照らして、最低限の検証を行う。

例：

ask > bid であるか

price > 0 であるか

時刻やTick番号が逆行していないか


ただし、すべてを疑うことはしない。

> 入力側の責務は
「前提条件が破られていないか」を確認すること




---

4. 契約（Contract）という考え方

Aegisでは、モジュール間のデータ受け渡しを
**暗黙の契約（Contract）**として扱う。

出力側：契約に沿った形式でデータを渡す

入力側：契約違反のみを検出する


これにより、

正常系の処理を高速に保ち

異常系を即座に特定可能とする



---

5. パフォーマンスとの両立

この設計思想は、以下を前提とする。

正常系では最小限のチェックのみを行う

詳細検証はデバッグ・検証モードで有効化する

問題発生時に、チェックレベルを引き上げられる構造とする


これにより、

> 安全性とパフォーマンスの両立を実現する




---

6. Aegisにおける意義

この考え方により、Aegisは以下の特性を得る。

「動いているが壊れている」状態を排除できる

問題発生時に原因特定が容易になる

時間差・状態遷移を伴う複雑な構造でも破綻しにくい


これは単なる防御的設計ではなく、

> 説明可能性と再現性を重視するAegisの中核思想



である。


---

🔖 位置づけの提案（仕様書内）

設計思想 / 基本原則 セクション
もしくは

共通設計ルール（全レイヤー共通）


として配置するのが自然です。


---

次の一手としては、どちらもアリです👇

この覚書を 正式仕様に昇格させる

「観測層・判断層・実行層」に
この原則をどう当てはめるかを追記する


どうします？
今の流れ、かなり“設計が締まってきている”感触がありますよ。

================================================================================
観測→状態→判断→実行の流れ／観測値の扱い／将来拡張のための布石
================================================================================
了解。今日の議論の要点を、**仕様書ほど堅くなく**、でも後で読み返して「その時点の意思決定」が追える形で **Aegis設計覚書** にまとめます。
（※日付入り・日本語・コードなし）

---

# Aegis設計覚書

**作成日:** 2026-01-08
**作成者:** ChatGPT（PM）
**目的:** 本日の議論（観測→状態→判断→実行の流れ／観測値の扱い／将来拡張のための布石）を、後日参照できる「設計の覚書」として残す。

---

## 1. 前提の再確認

Aegisは「複雑なロジックを積み上げるEA」ではなく、
**入力→処理→出力** を明確にし、かつ **説明可能性** を維持することを重視する。

特に重要な基本姿勢：

* 各モジュールは **出力の正当性・正確性** を（可能な範囲で）保証する
* 受け取る側は **付属情報の異常検知** を行う
* これにより処理が重くなる可能性はあるが、Aegisの思想上「必要な強さ」とみなす

---

## 2. 用語の整理（層よりもシーケンス）

「層（レイヤー）」という言葉は、上下関係や呼び出し関係を誤解させやすい。
Aegisの実態は **バトンを回す“シーケンス”** に近い。

推奨イメージ：

1. **実行権の付与**（Tick開始、処理開始）
2. **観測（Observation）**：事実（複数可）を集める／要約する
3. **状態確定（State化）**：観測結果をもとに「現在の状態」を確定する
4. **判断（Decision）**：確定した状態から、次のAction（Request）を選ぶ
5. **実行（Execution）**：選ばれたActionを実行し、結果（Result）を返す
6. **結果の反映**：次のTickでの観測／状態確定に使う（状態は結果により更新される）

---

## 3. 「観測層は判断しない」→ 表現の更新

本日の合意：

> 観測層は「意思決定」をしない

観測層がやるのは

* 事実の取得
* 要約（例：50tickで高値/安値を確定）
* 「観測が確定した／判断材料が揃った」という通知（フラグ等）

観測層は **行動を選ばない**。
Action（Request）を決めるのは判断側である。

---

## 4. 観測値の分類（カテゴリ化）の導入

観測機能が増える将来を見据え、観測値を “性質” で分類する考え方を導入する。
現時点の候補カテゴリ例：

* **PRICE系**：価格そのもの／高値・安値・レンジ等
* **VOLATILITY系**：ボラティリティ、バンド幅、変動性指標など
* **MOMENTUM系**：RSI/MACD等の勢い・方向性
* **TIME系**：市場オープンからの経過、クローズまでの残り、時間帯など
* **EVENT系**：経済指標、ニュース等のイベント由来の観測

※カテゴリに当てはまらない観測が出てきた場合、
それは「その観測が特殊」ではなく、**Aegisの判断体系をアップデートすべきサイン**になり得る。

---

## 5. 観測値の受け渡しと「スロット」構想

### 5.1 問題意識

観測層が増えると、観測値の保存先が必要になる。
単一の保存領域に上書きしてしまう設計では破綻する。

### 5.2 方針（現時点の方向性）

* 観測値は **CLA_Data に集約**する（唯一の受け渡し点）
* ただし、CLA_Dataを「解釈する存在」にしない（入れ物に徹する）
* 観測値は “配列で雑に管理” ではなく、**複数スロットとして保持**する方向を検討

### 5.3 動的スロットの理想像（夢構想としての整理）

* Init時に観測層が「登録」し、スロットを確保
* OnTick中はスロット構造を変更しない（不変・immutable）
* 参照はカテゴリやID単位（文字列名はデバッグ用途中心）

---

## 6. 判断の方向性（観測→状態→Action）

判断層についての、現時点の方向性（暫定）：

* 判断層は観測値を **直接“条件分岐の材料として乱用しない”**
* 観測値群を評価して **単一の状態（State）に確定**し、
* 状態から **次のAction（Request）を選択**する

ただし注意：

* if/switch等の分岐そのものを否定するわけではない
* 「分岐の書き方」ではなく、**説明可能な中間表現（State）を置く**ことが重要

---

## 7. 頻度設計（50Tick / 10秒 / 1分 など）

観測や判断・実行を毎Tickで行うのは、将来の指標計算（MA/BB/RSI等）では負荷が高い。

そこで、頻度設計の考え方を導入する：

* Tickカウントによる間引き（例：N Tickごと）
* 時間による間引き（例：10秒、1分ごと）
* 「前回実行（注文変更）時刻」を保持し、それと現在時刻を比較する方式

重要：

* N=50は仮値であり、**埋め込み禁止**（外部設定・パラメータ化が前提）

また、

* 50回の間の「高値・安値（必要なら始値・終値）」は観測として扱う
* これは観測層が「意思決定」ではなく「要約」をする例として整合する

---

## 8. 実行遅延リスクの扱い

「実行できるTick（例：N回に1回）以外では実行されない」場合、
何らかのトラブルでActionがスルーされると **次の実行が遅れる**懸念がある。

現時点の整理：

* 追従（Modify）の頻度は間引いてよい
* ただし、**緊急性の高いAction（例：Cancel）は別扱い**にできる余地がある
* この線引きは今後の設計項目（“Actionの緊急度”など）

---

## 9. 現段階の合意（今日の到達点）

* 追従型は現状でも動くが、今日の議論を「少しだけ」意識することで将来拡張が楽になる可能性がある
* 観測層は「意思決定」をしない
* 観測値はカテゴリ化して捉えると整理しやすい
* 観測値の受け渡しはCLA_Data集約が基本
* 観測値スロット（動的登録構想）は将来の布石として有望
* 頻度設計（N tick / 時間間隔）はパフォーマンス面で避けて通れない

---

## 10. 次アクション（今すぐやる／後でやる）

### 今すぐやる候補（小さく）

* 「観測値カテゴリ」の概念を仕様書の用語に追加（1段落程度）
* “頻度設計は必須” を方針として明記

### 後でやる候補（段階導入）

* 観測値スロット構想のフェーズ分割（最小2スロットから）
* Actionの緊急度（間引き対象／対象外）の整理

---

以上。
この覚書は、**現時点の意思決定ログ**として保存することを目的とする。







================================================================================

