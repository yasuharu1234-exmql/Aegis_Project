
---

# Phase 6 状態ログ実装仕様書 v2.1

**作成日**: 2026-01-02  
**作成者**: Genspark AI (PM) + ChatGPT (設計思想) + Claude (実装レビュー)  
**対象**: Aegis Hybrid EA - Phase 6 状態ログ実装

---

## 📋 変更履歴

| バージョン | 日付 | 変更内容 | 変更者 |
|-----------|------|---------|--------|
| v1.2 | 2026-01-02 | 叩き台作成 | Genspark AI |
| v2.0 | 2026-01-02 | 正式版（ChatGPT作成） | ChatGPT |
| **v2.1** | 2026-01-02 | **Claude実装レビュー反映** | Genspark AI + ChatGPT |

### **v2.1 の主要変更点**

1. **第4章「ログ出力ルール」に2つのルール追加**
   - 4.6.4 中間値のログ抑制
   - 4.6.5 スプレッドログの状態優先原則

2. **第7章「Phase 2-1 詳細実装仕様」を新規追加**
   - 追加メンバ変数の確定版
   - 追加メソッドの確定版（EnterState / ResetLogState / GetState）
   - 既存コード修正箇所の明記

3. **第8章「新規パラメータ」に補足追記**
   - InpSpreadLogDelta の動作詳細
   - InpNoChangeLogDelta の中間値扱い

4. **第9章「仕様上の注意事項」に追記**
   - 9.8 ログ抑制の優先順位

---

## 第1章 概要・目的・成功条件

### 1.1 本章の目的

本章は、Aegis Hybrid EA における **Phase 6「状態ログ実装」** の目的・範囲・成功条件を定義する。

### 1.2 Phase 6の位置づけ

Phase 6 は、EAの売買ロジックや戦略を変更せず、**「なぜその動作をしたかを後から説明できる状態にするための骨格作り」** を目的とする。

- ログの網羅性・最適化・美観は対象外
- 後続Phase（Phase 7）で拡張・洗練する前提とする

### 1.3 Phase 6の目的

- トレード結果に対し、事後分析が可能なログを残す
- 「なぜ動いたか／なぜ動かなかったか」を追跡可能にする
- 毎Tickログを避け、実運用に耐える記録量に抑制する

### 1.4 Phase 6の範囲

**Phase 6に含めるもの:**
- 通常状態ログ（100番台）
- 状態遷移ベースの記録ルール
- CSV出力基盤
- 記録種別番号体系の確定と予約

**Phase 6に含めないもの:**
- パニックログの本実装（200番台）
- スポットログの本実装（300番台）
- ログを用いた判断・制御機構

### 1.5 成功条件

Phase 6の成功条件は以下とする。

1. ログを見て「なぜそう動作したか」を説明できる
2. LogIDとパラメータの意味が仕様書と一致している
3. 毎Tickログが発生しない
4. 長期テスト（1か月程度）でログ量が実用範囲に収まる

---

## 第2章 設計思想（Aegisログ設計原則）

### 2.1 基本思想

Aegisのログ設計は、以下の思想を前提とする。

> **「なぜ負けたかわからない」を最大の失敗とする**

### 2.2 判断と報告の分離

- 判断は Strategy / Decision 層が行う
- ログは **起きた事象を記録するのみ**
- ログ記録層は、売買判断・制御判断を行わない

### 2.3 状態変化時のみ記録

- 毎Tickの価格更新ではログを出力しない
- 状態が「変化した瞬間」のみ記録する
- 同一状態が継続する場合は初回のみ記録する

### 2.4 説明可能性の優先

- ログは最小ではなく「理解可能」を優先する
- 数値（価格・差分・閾値）を必ず記録対象に含める
- 省略によって判断理由が不明になる設計を避ける

### 2.5 型安全性の確保

**Param1〜Param4 は数値型のみ使用:**
- 整数：チケット番号、回数、ポイント値
- 浮動小数：価格、指標値

**文字列は説明文フィールドのみに限定:**
- 文字列長は最大256文字とする

### 2.6 段階実装前提

- Phase 6は骨格のみを実装
- 仕様は後方互換を前提に拡張可能とする
- ロールバック可能な実装順序を維持する

---

## 第3章 ログ分類と番号体系

### 3.1 番号体系の目的

ログの種類を **番号帯で明確に分離** し、将来の拡張・解析・自動処理を容易にする。

### 3.2 番号体系（確定）

| 番号帯 | 分類 | 対象Phase | 状態 |
|--------|------|-----------|------|
| **100番台** | 通常状態ログ | Phase 6 | 実装対象 |
| **200番台** | パニックログ | Phase 7 | 予約 |
| **300番台** | スポットログ | Phase 7 | 予約 |
| **3000番台** | 実行層ログ | 既存 | 運用中 |

### 3.3 100番台（通常状態ログ）の位置づけ

- Phase 6で実装する唯一のログ分類
- 戦略・判断・実行の結果として起きた事象を記録
- 状態遷移・閾値超過・イベント発生時のみ出力

### 3.4 200番台（パニックログ）の位置づけ

- Phase 6では実装しない
- 致命的異常時の記録を想定
- Phase 7で設計・実装を行う

### 3.5 300番台（スポットログ）の位置づけ

- Phase 6では実装しない
- デバッグ・調査用途の条件付き記録を想定
- Phase 7で設計・実装を行う

### 3.6 将来拡張方針

- 番号帯の意味は固定とする
- 番号の欠番は将来用途のため許容する
- 番号帯を跨ぐ意味の混在は禁止する

---

## 第4章 Phase 6 実装範囲：通常状態ログ（100番台）

### 4.1 本章の目的

本章は、Phase 6で実装する **通常状態ログ（100番台）** の仕様を定義する。

ログの目的は、EAの動作を **事後に説明可能** にすることであり、挙動の最適化や戦略改善は対象外とする。

### 4.2 ログ出力形式（共通）

#### 4.2.1 出力形式

ログは CSV 形式で出力する。

```
Time_ms,TickSeq,Level,LogID,LogName,Param1,Param2,Param3,Param4,Message
```

#### 4.2.2 各フィールド定義

| フィールド | 型 | 内容 |
|-----------|-----|------|
| Time_ms | 整数 | ミリ秒単位の時刻 |
| TickSeq | 整数 | 市場価格更新番号（連番） |
| Level | 固定文字列 | INFO / WARN / ERROR |
| LogID | 整数 | 記録種別識別子 |
| LogName | 固定文字列 | 記録種別名称（最大32文字） |
| Param1〜4 | 数値 | LogID固有のパラメータ |
| Message | 文字列 | 補足説明（最大256文字） |

### 4.3 重要度（Level）の定義

| 重要度 | 意味 |
|--------|------|
| INFO | 正常な状態変化 |
| WARN | 想定内だが注意が必要な状態 |
| ERROR | 処理継続可能な異常 |

※ FATAL は Phase 6 では使用しない。

### 4.4 通常状態ログ一覧（100番台）

| LogID | 名称 | 概要 |
|-------|------|------|
| 100 | OCO_PLACE | 両建て注文配置成功 |
| 101 | MODIFY_TRY | 注文価格変更試行 |
| 102 | MODIFY_OK | 注文価格変更成功 |
| 103 | MODIFY_FAIL | 注文価格変更失敗 |
| 104 | NO_CHANGE | 価格変更不要 |
| 105 | SPREAD_SKIP | スプレッド超過により追従中断 |
| 106 | SPREAD_OK | スプレッド正常化により追従再開 |
| 107 | TRAIL_TRIGGER | 追従トリガー発動 |
| 108 | CANCEL_OK | 注文取消成功 |
| 109 | FILL_DETECT | 約定検出 |
| 110 | DECISION | 判断結果記録 |
| 111 | DECISION_SKIP | 判断保留理由記録 |

### 4.5 LogID別 パラメータ定義（抜粋）

#### 4.5.1 LogID 100：OCO_PLACE
- Param1：Buy注文チケット番号
- Param2：Buy注文価格
- Param3：Sell注文チケット番号
- Param4：Sell注文価格
- Message：判断理由（例：RSI=72.5 → Sell優先）

#### 4.5.2 LogID 104：NO_CHANGE
- Param1：Buy価格差分（pt）
- Param2：Sell価格差分（pt）
- Param3：0
- Param4：0
- Message：価格変更不要理由

#### 4.5.3 LogID 105：SPREAD_SKIP
- Param1：現在スプレッド（pt）
- Param2：許容スプレッド（pt）
- Param3：Ask
- Param4：Bid
- Message：スプレッド超過理由

#### 4.5.4 LogID 107：TRAIL_TRIGGER
- Param1：価格変動量（pt）
- Param2：トリガー閾値（pt）
- Param3：現在追従回数
- Param4：最大追従回数
- Message：追従発動理由

#### 4.5.5 LogID 110：DECISION
- Param1：指標値（例：RSI）
- Param2：閾値
- Param3：0
- Param4：0
- Message：判断内容

### 4.6 記録ルール

#### 4.6.1 状態変化時のみ記録

- 状態が変化した瞬間のみログを出力する
- 同一状態の連続記録は禁止

#### 4.6.2 初回のみ記録ルール

- NO_CHANGE 等の継続状態は初回のみ記録
- 状態が変化した場合にフラグをリセットする

#### 4.6.3 変化量閾値ルール

- 数値変化が微小な場合は記録しない
- 閾値は外部パラメータで制御する

#### 4.6.4 中間値のログ抑制 ⭐ **v2.1 新規追加**

**InpNoChangeLogDelta を超え、InpTrailTriggerPoints 未満の価格変動は記録しない。**

**理由:**
- 追従もせず、状態も変わらない = 判断結果として何も起きていない
- 中間値はノイズ領域
- 中間挙動の可視化はPhase 7（スポットログ）の役割

**例:**
```
InpNoChangeLogDelta = 5pt
InpTrailTriggerPoints = 100pt
価格差分 = 70pt の場合 → ログを出さない
```

#### 4.6.5 スプレッドログの状態優先原則 ⭐ **v2.1 新規追加**

**スプレッドログは「状態遷移」を主条件とし、変化量閾値は補助条件としてのみ使用する。**

**状態変化なし（OK→OK または NG→NG）の場合:**
- 変化量が InpSpreadLogDelta を超えていてもログを出さない

**状態遷移（OK⇔NG）の場合:**
- 変化量に関係なくログを出す

**理由:**
- Phase 6の原則：状態変化時のみ記録
- 変化量ログを許すと「状態ログ」が「メトリクスログ」に崩壊する

### 4.7 記録禁止事項

- 毎Tickの価格ログ
- ログ内での判断・分岐処理
- ログ出力をトリガーとした売買制御

---

## 第5章 Phase 7への展望：CriticalSnapshotLogger

### 5.1 本章の位置づけ

本章は Phase 7で実装予定 の拡張ログ機構について、Phase 6時点での **設計方針のみ** を定義する。

本章に記載された内容は **Phase 6では実装対象外** とする。

### 5.2 基本方針

#### 5.2.1 内部統合・外見分離

Phase 7では以下の2種ログを **内部的に同一基盤** で実装する。

- パニックログ（200番台）
- スポットログ（300番台）

ただし、以下は **外見上分離** する。

- 出力ファイル
- LogID番号帯
- 利用目的

### 5.3 CriticalSnapshotLogger 概念

#### 5.3.1 役割

CriticalSnapshotLogger は、**重要な瞬間の状態スナップショットを記録する共通基盤** である。

- 通常ログとは異なり「点」で状態を切り取る
- 記録対象は可能な限り包括的とする

#### 5.3.2 対象ログ種別

| 種別 | 目的 |
|------|------|
| パニックログ | 致命的異常発生時の遺言 |
| スポットログ | デバッグ・調査用の任意スナップショット |

### 5.4 パニックログ（200番台）設計方針

#### 5.4.1 目的
- システム継続が困難な事象の記録
- 事後分析における最終証拠の保存

#### 5.4.2 特徴
- 自動トリガー
- 記録回数は極少（通常は0）
- EA停止判断とは分離する（記録のみ）

#### 5.4.3 出力
- 専用ファイル：PanicLog_*.csv
- Phase 6のCSVフォーマットを継承

### 5.5 スポットログ（300番台）設計方針

#### 5.5.1 目的
- デバッグ・検証・調査支援
- 特定条件成立時の詳細記録

#### 5.5.2 特徴
- 条件指定による手動・半自動トリガー
- 本番運用でも使用可能（条件は慎重に設定）
- 判断ロジックは最小限に制限

#### 5.5.3 出力
- 専用ファイル：SpotLog_*.csv
- 通常状態ログと同一フォーマット

### 5.6 設計思想との整合性

#### 5.6.1 判断と報告の分離
- トリガー判断は **記録開始条件の判定のみ**
- 売買・戦略判断は一切行わない

#### 5.6.2 Phase 6との関係
- Phase 6では **予約のみ**
- LogID番号帯の確保のみ実施
- 実装・詳細仕様は Phase 7 で確定

### 5.7 Phase 6への影響

- Phase 6実装には影響なし
- CSVフォーマットの拡張不要
- ロガー基盤は Phase 7拡張を前提に設計する

---

## 第6章 記録量見積もり

### 6.1 見積もりの前提条件

本見積もりは、以下の条件を前提とする。

- 対象：通常状態ログ（100番台）のみ
- 記録方式：状態変化時のみ記録
- 毎Tickログ：行わない
- テスト実績：
  - 約 2,100,000 Tick / 月
  - 約 639 トレード / 月

### 6.2 記録頻度の想定

#### 6.2.1 主な記録発生ポイント

| 種別 | 想定発生頻度 |
|------|-------------|
| 注文配置 | トレード開始時のみ |
| 追従発動 | 数回〜十数回 / トレード |
| 変更成功 / 失敗 | 追従発動時のみ |
| 追従中断 / 再開 | 状態変化時のみ |
| 判断記録 | 判断確定時のみ |
| 判断保留 | 状態変化時のみ |

#### 6.2.2 トレードあたりの想定ログ数

- 最小：5〜8行
- 平均：10〜15行
- 最大（荒い相場）：20行程度

### 6.3 月間ログ行数見積もり

#### 6.3.1 計算式

```
月間ログ行数 ≒ トレード数 × 平均ログ数
```

#### 6.3.2 見積もり結果

```
639 トレード × 10〜15 行
→ 約 6,000〜10,000 行 / 月
```

※ スプレッド急変など特殊条件を含めても15,000 行 / 月を超えることは想定しない

### 6.4 ファイル容量見積もり

#### 6.4.1 1行あたりの容量

| 項目 | 想定サイズ |
|------|-----------|
| 数値フィールド | 約 60 バイト |
| 名称フィールド | 最大 32 バイト |
| 説明文 | 最大 256 バイト |
| 区切り・制御文字 | 約 10 バイト |
| **合計** | **約 350 バイト / 行** |

#### 6.4.2 月間容量

```
10,000 行 × 350 バイト
→ 約 3.5 MB / 月
```

#### 6.4.3 年間容量（参考）

```
約 40〜50 MB / 年（通常状態ログのみ）
```

### 6.5 パフォーマンス影響評価

#### 6.5.1 CPU負荷
- 状態変化時のみ書き込み
- 毎Tick処理への影響は無視できるレベル

#### 6.5.2 IO負荷
- 書き込み頻度が低いため問題なし
- CSV追記方式を前提

### 6.6 ログ爆発リスク評価

#### 6.6.1 想定されるリスク
- 状態判定ロジックの誤実装
- 状態フラグ未リセットによる多重記録

#### 6.6.2 抑制策
- 状態フラグ管理の厳密化
- IDLE遷移時の明示的リセット
- Phase 6ではデバウンス導入なし

### 6.7 結論

- 月間ログ量：現実的かつ管理可能
- ストレージ・性能への影響：問題なし
- Phase 6の目的（説明可能性）を阻害しない

---

## 第7章 Phase 2-1 詳細実装仕様 ⭐ **v2.1 新規追加**

### 7.1 Phase 2-1の目的

Phase 2-1は、Phase 2-2以降のログ追加実装の基盤を整備する。

**具体的には以下を実装する:**

1. ログ状態管理用メンバ変数の追加
2. m_stateのprivate化とアクセサ整備
3. 状態遷移時の自動ログリセット機構

### 7.2 追加メンバ変数（確定版）

```cpp
private:
   // ===== ログ状態管理 =====
   bool     m_no_change_logged;       // NO_CHANGE初回ログ済みフラグ
   bool     m_spread_ng_prev;         // 前回スプレッド状態（NG=true）
   int      m_spread_last_logged;     // 前回ログ記録時のスプレッド値（pt）
   double   m_buy_price_last_logged;  // 前回ログ記録時のBuy価格
   double   m_sell_price_last_logged; // 前回ログ記録時のSell価格
   
   // ===== m_stateのprivate化 =====
   ENUM_OCO_STATE m_state;
```

**初期値:**
- `m_no_change_logged = false`
- `m_spread_ng_prev = false`
- `m_spread_last_logged = 0`
- `m_buy_price_last_logged = 0.0`
- `m_sell_price_last_logged = 0.0`

### 7.3 追加メソッド（確定版）

#### 7.3.1 ResetLogState()

```cpp
private:
   void ResetLogState()
   {
      m_no_change_logged = false;
      m_spread_ng_prev = false;
      m_spread_last_logged = 0;
      m_buy_price_last_logged = 0.0;
      m_sell_price_last_logged = 0.0;
   }
```

**責務:**
- ログ状態管理用フラグを初期化
- IDLE遷移時に自動呼び出し

#### 7.3.2 EnterState()

```cpp
public:
   void EnterState(ENUM_OCO_STATE new_state)
   {
      m_state = new_state;
      
      // IDLE遷移時にログ状態リセット
      if(new_state == OCO_STATE_IDLE)
      {
         ResetLogState();
      }
   }
```

**責務:**
- 状態遷移
- IDLE遷移時の自動ログリセット

**設計意図:**
- 状態遷移は必ず副作用（ログ状態リセット）を伴う
- 人間の呼び忘れに委ねる設計は危険
- 後回しにするとログ破綻の温床

#### 7.3.3 GetState()

```cpp
public:
   ENUM_OCO_STATE GetState() const { return m_state; }
```

**責務:**
- 状態の参照専用

### 7.4 既存コード修正箇所

#### 7.4.1 直接代入の修正（9箇所）

```cpp
// 修正前
m_state = OCO_STATE_ACTIVE;
m_state = OCO_STATE_COMPLETED;
m_state = OCO_STATE_IDLE;

// 修正後
EnterState(OCO_STATE_ACTIVE);
EnterState(OCO_STATE_COMPLETED);
EnterState(OCO_STATE_IDLE);
```

#### 7.4.2 switch文の修正（1箇所）

```cpp
// 修正前
switch(m_state) { ... }

// 修正後
switch(GetState()) { ... }
```

**理由:**
- 可読性向上
- 将来拡張時の変更容易性

#### 7.4.3 比較の修正（3箇所）

```cpp
// 修正前
if(m_state == OCO_STATE_COMPLETED) { ... }

// 修正後
if(GetState() == OCO_STATE_COMPLETED) { ... }
```

### 7.5 Phase 2-1 完了条件

以下を全て満たした時点でPhase 2-1完了とする:

1. コンパイルエラー・警告なし
2. 既存挙動が完全に一致（ログ未追加でも）
3. EnterState(OCO_STATE_IDLE) でログ状態がリセットされる
4. m_stateへの直接アクセスがprivate化により禁止されている

---

## 第8章 新規パラメータ

### 8.1 目的

状態ログの記録頻度と情報密度を制御するため、Phase 6では最小限の外部パラメータを追加する。

ログ量の抑制と説明可能性の両立を目的とする。

### 8.2 新規追加パラメータ一覧

#### 8.2.1 InpSpreadLogDelta

```cpp
input int InpSpreadLogDelta = 10;  // スプレッド変化量ログ閾値（1.0pips）
```

**用途:**
- スプレッド状態遷移（OK⇔NG）時の補助条件
- 状態変化なしの場合、単独ではログを出さない ⭐ **v2.1 補足**

**動作:** ⭐ **v2.1 補足**
- **状態遷移あり** → 変化量に関係なくログ出力
- **状態遷移なし** → ログ出さない（変化量が大きくても）

**目的:**
- 微小変動によるログ爆発の防止
- 状態変化の本質のみを記録

---

#### 8.2.2 InpNoChangeLogDelta

```cpp
input int InpNoChangeLogDelta = 5;  // 価格差分無視閾値（0.5pips）
```

**用途:**
- 変更不要ログ（104）の判定補助

**仕様:**
- Buy/Sell の価格差分が両方とも InpNoChangeLogDelta pt 未満の場合、「変更不要」と判定
- 初回のみログ記録、以降は抑制

**中間値の扱い:** ⭐ **v2.1 補足**
```
InpNoChangeLogDelta 〜 InpTrailTriggerPoints の範囲の価格変動は記録しない

理由: ノイズ領域、Phase 7で可視化
```

**目的:**
- 意味のない MODIFY 試行の説明
- ノイズ的な価格揺れの排除

---

#### 8.2.3 InpEnableStateLog

```cpp
input bool InpEnableStateLog = true;  // 通常状態ログ有効/無効
```

**用途:**
- 通常状態ログ（100番台）の全体ON/OFF制御

**仕様:**
- false の場合、AddLogEx 呼び出しは行われない
- ロジック・状態管理には影響を与えない

**目的:**
- パフォーマンス検証用
- 比較テスト時の切り替え

---

### 8.3 パラメータ設計方針

- Phase 6では必要最小限
- デバッグ用途の細かい制御は Phase 7 に委ねる
- すべて input 変数として定義
- ログ制御がロジック判断に影響を与えてはならない

### 8.4 既存パラメータとの関係

```
InpMaxSpreadPoints  → 判断条件
InpSpreadLogDelta   → 記録条件
```

**判断と記録の責務を明確に分離する。**

---

### 8.5 Pips入力対応（Phase 7以降） ⭐ **v2.1 補足**

**現状:**
- 内部実装は**ポイント基準**を継続
- パラメータコメントに**Pips換算を併記**

**Phase 7以降の対応:**
- 人間が入力する場合は**Pipsで入力** → 内部で**ポイントに自動変換**

**例:**
```cpp
input double InpMaxSpreadPips = 15.0;  // スプレッド上限（Pips入力）

// 内部でポイント変換
int max_spread_points = (int)(InpMaxSpreadPips * (_Digits == 3 || _Digits == 5 ? 10 : 1));
```

---

## 第9章 仕様上の注意事項

### 9.1 判断と記録の分離の厳守

ログは事象の結果を記録するだけとする。

**ログ記録処理内で以下を行ってはならない:**
- 状態遷移の判断
- パラメータ補正
- 処理分岐の決定

**ログは常に「判断の後」に呼び出される。**

---

### 9.2 毎Tick記録の禁止

市場価格更新（OnTick）ごとの記録は禁止。

**記録対象は以下に限定する:**
- 状態遷移
- 閾値超過
- 初回発生イベント

**Tick回数はログのトリガー条件にしてはならない。**

---

### 9.3 状態フラグ管理の注意点

- ログ抑制用フラグは戦略クラスのメンバ変数として保持
- static ローカル変数の使用は禁止
- IDLE 状態遷移時には、以下を必ずリセットする:
  - NO_CHANGE 記録フラグ
  - スプレッド状態フラグ
  - 追従回数カウンタ
  - 直前記録値（価格・スプレッド）

---

### 9.4 ログ抑制ロジックの優先順位

1. 状態遷移の有無
2. 変化量閾値（InpSpreadLogDelta 等）
3. 初回記録フラグ

**抑制ロジックは必ずこの順序で評価する。**

---

### 9.5 CSV出力の注意事項

**RFC4180 準拠のエスケープ処理を行う:**

**エスケープ対象:**
- `,`（カンマ）
- `"`（ダブルクォート）
- 改行文字

**エスケープ不要:**
- 数値フィールド

**エスケープ対象:**
- 説明文フィールドのみ

---

### 9.6 パフォーマンス上の注意

- 文字列生成（StringFormat）は記録確定後のみ行う
- 抑制条件を満たさない場合、説明文生成は禁止
- AddLogEx 呼び出しは最小限にする

---

### 9.7 テスト時の注意事項

Phase 6テストでは以下を重点確認:

- 意味のないログが出ていないか
- 状態遷移が欠落していないか
- ログ抑制が効きすぎていないか

**ログが「少なすぎる」場合は失敗とみなす。**

---

### 9.8 ログ抑制の優先順位 ⭐ **v2.1 新規追加**

ログ抑制は以下の優先順位で判定する:

**優先度1: 状態遷移の有無**
- 状態遷移あり → ログ出力候補
- 状態遷移なし → ログ抑制候補

**優先度2: 変化量閾値**
- InpSpreadLogDelta / InpNoChangeLogDelta を超えているか

**優先度3: 初回記録フラグ**
- 同一状態の初回のみ記録

**優先度4: 中間値の除外**
- InpNoChangeLogDelta 〜 InpTrailTriggerPoints は記録しない

---

## 第10章 実装フェーズ計画

### 10.1 実装方針の概要

Phase 6の実装は、影響範囲を最小化しつつ段階的に進めることを原則とする。

- 1ファイルずつ実装・確認
- 既存挙動を壊さない（後方互換）
- ロールバック可能な単位で進行

### 10.2 フェーズ構成

#### **Phase 2-1：基盤整備**

**目的:**
状態ログ実装のための基盤を整える。

**主な内容:**
- 状態遷移管理用メンバ変数の追加
- 状態リセット処理の共通化
- 状態フラグの private 化とアクセサ整備

**対象:**
- CStrategy_OCOFollow.mqh

**完了条件:**
- ログ未追加でも既存挙動が完全に一致すること
- コンパイルエラー・警告なし

---

#### **Phase 2-2：通常状態ログ追加（戦略層）**

**目的:**
戦略判断・状態遷移の説明可能性を確保する。

**主な内容:**
- 追従発動ログ（107）
- 追従中断／再開ログ（105 / 106）
- 変更不要ログ（104）
- 注文配置ログ（100）
- 約定検出ログ（109）

**ルール:**
- 状態変化時のみ記録
- 連続同一ログは初回のみ
- 変化量閾値を適用

**対象:**
- CStrategy_OCOFollow.mqh

**完了条件:**
- 意味のあるログがCSVに出力されること
- ログ量が想定範囲内であること

---

#### **Phase 3：実行層ログ追加**

**目的:**
「実行した結果」を追跡可能にする。

**主な内容:**
- MODIFY成功／失敗ログ（102 / 103）
- 注文取消ログ（108）
- OCO配置成功ログ（100補助）

**対象:**
- CExecutionManager.mqh

**完了条件:**
- 実行結果と戦略ログの時系列が一致すること

---

#### **Phase 4：ゲートキーパー層ログ追加**

**目的:**
「なぜ通さなかったか」を説明可能にする。

**主な内容:**
- スプレッド拒否理由ログ
- 前提条件NG時の理由記録

**対象:**
- CGatekeeper.mqh

**ルール:**
- 拒否時のみ記録
- 成功時は記録しない

---

#### **Phase 5：判断層ログ追加**

**目的:**
市場判断の根拠を明確化する。

**主な内容:**
- 判断確定ログ（110）
- 判断保留ログ（111）

**対象:**
- CDecisionRSI_Simple.mqh

**完了条件:**
- 「なぜその判断になったか」が後追い可能であること

---

### 10.3 実装順序（厳守）

1. Phase 2-1（基盤整備）
2. Phase 2-2（戦略層ログ）
3. Phase 3（実行層）
4. Phase 4（ゲートキーパー）
5. Phase 5（判断層）

※ 複数ファイル同時実装は禁止

### 10.4 テスト方針（Phase 6）

- 単体テスト：各Phase完了ごと
- 結合テスト：Phase 5完了後
- 長期テスト：1週間以上のテスター実行

**確認ポイント:**
- ログの意味が説明可能か
- ログ量が想定内か
- 毎Tickログが発生していないか

### 10.5 Phase 6完了条件

以下をすべて満たした時点でPhase 6完了とする。

- CSVログからトレード挙動を説明できる
- ログ爆発が発生していない
- 既存ロジックの挙動が変わっていない

---

## 第11章 レビューおよび承認条件

### 11.1 レビュー観点（必須）

本仕様は、以下の観点でレビューされることを前提とする。

1. **説明可能性**: 各ログから「なぜその動作に至ったか」を追跡できるか
2. **過不足の有無**: ログが多すぎず、少なすぎないか
3. **設計思想の遵守**: 判断と記録の分離が守られているか
4. **将来拡張性**: Phase 7（パニック／スポット）への拡張余地があるか

---

### 11.2 Phase 6 合格条件（GO基準）

以下すべてを満たした場合、Phase 6 は **完了（GO）** とする。

- 通常状態ログ（100番台）が出力される
- ログ内容が人間にとって理解可能である
- 毎Tickログが一切発生していない
- 1ヶ月テストでログが破綻しない
- CSVが後処理（Excel / スクリプト）で解析可能

**勝率・利益率は評価対象外。**

---

### 11.3 不合格条件（NO GO）

以下のいずれかに該当した場合、Phase 6 は **差し戻し** とする。

- ログを見ても動作理由が説明できない
- 同一ログが大量に連続出力される
- 状態遷移がログに現れない
- 重要な判断が無記録で行われている
- 実装が仕様書と乖離している

---

### 11.4 レビュアー別の役割

| レビュアー | 役割 |
|-----------|------|
| ヤスハル | 設計思想・実運用視点での最終承認 |
| ChatGPT | 設計一貫性・思想チェック |
| Gemini | 技術的盲点・境界条件チェック |
| Claude | 実装可能性・工数妥当性チェック |

---

### 11.5 承認フロー

1. Claude による実装完了
2. テスターによる短期検証（数日〜1週間）
3. ログレビュー（人間）
4. 本章の合格条件チェック
5. Phase 7 への移行判断

---

## 第12章 Phase 7 への移行条件と展望

### 12.1 Phase 7 の位置づけ

Phase 7 は、Phase 6 で確立した **通常状態ログ（100番台）** を基盤として、異常系・詳細解析系ログを拡張するフェーズである。

**Phase 6 が「骨格」、Phase 7 は「神経系・記憶拡張」に相当する。**

---

### 12.2 Phase 7 移行の前提条件

以下が **すべて満たされた場合のみ** Phase 7 に進む。

- Phase 6 が GO 判定されている
- 通常状態ログのみで基本挙動を説明できる
- ログ量・性能に致命的問題がない
- 実運用テストでログの価値が確認できている

※ Phase 6 が不安定な状態で Phase 7 に進むことは禁止。

---

### 12.3 Phase 7 の主目的

1. 致命的状況の完全記録
2. ピンポイントな詳細解析
3. 人間の調査コスト削減

**Phase 7 は「普段は静か、必要な時だけ饒舌」を目標とする。**

---

### 12.4 パニックログ（200番台）の役割（展望）

**目的:**
- EA継続が困難な状況での「最終記録」

**特徴:**
- 発生頻度は極めて低い
- 状態スナップショット重視
- 人間向けの可読性を最優先

**想定トリガー:**
- 内部整合性崩壊
- 連続致命エラー
- 制御不能状態検出

---

### 12.5 スポットログ（300番台）の役割（展望）

**目的:**
- 特定条件下の詳細観測

**特徴:**
- 人為的・条件付きトリガー
- 通常ログより情報量が多い
- 一時的な解析用途

**想定用途:**
- デバッグ
- 特定トレードの原因分析
- ロジック検証

---

### 12.6 内部統合構想（CriticalSnapshotLogger）

Phase 7 では以下の内部構造を想定する。

**内部実装は共通、外見（LogID / ファイル）は分離**

| 項目 | パニック | スポット |
|------|---------|---------|
| トリガー | 自動 | 条件指定 |
| 頻度 | 極低 | 低 |
| 目的 | 遺言 | 観測 |
| 出力 | 最大情報 | 必要情報 |

---

### 12.7 Phase 6 と Phase 7 の明確な境界

| 項目 | Phase 6 | Phase 7 |
|------|---------|---------|
| ログ種別 | 状態変化 | 異常・詳細 |
| 判断 | しない | トリガーのみ |
| 情報量 | 最小限 | 多い |
| 常時有効 | Yes | No / 条件付き |

---

### 12.8 本仕様書のスコープ外宣言

以下は **本仕様書では扱わない**。

- パニックログの具体的フォーマット
- スポット条件DSL
- メモリダンプ手法
- 外部解析ツール連携

**これらは Phase 7 の別仕様書で定義する。**

---

## 第13章 まとめ ― Phase 6 の完成定義

### 13.1 Phase 6 の完成条件（定義）

Phase 6 は、以下をすべて満たした時点で **完了（DONE）** とする。

1. 通常状態ログ（100番台）が安定して出力される
2. ログを読めば「なぜその動作をしたか／しなかったか」が説明できる
3. 毎Tickログが発生しない
4. ログによる性能劣化が実用上問題にならない
5. ログ設計が Phase 7 拡張を阻害しない

---

### 13.2 Phase 6 で「やらないこと」の再確認

Phase 6 では以下を **意図的に実装しない**。

- パニックログの詳細実装
- スポットログの詳細実装
- 全変数・全状態のダンプ
- ログ最適化の追求
- 完璧な網羅性

**理由:**  
Phase 6 は **骨格構築フェーズ** であり、完成形を目指さないため。

---

### 13.3 Phase 6 の価値

Phase 6 により、Aegis は以下を獲得する。

- 「勝った／負けた」ではなく「なぜそうなったか」を説明できるEA
- AI・人間双方が解析可能なログ構造
- ロジック改善のための客観的証拠
- 将来拡張（Phase 7）への安全な足場

---

### 13.4 成功基準の最終宣言

**Phase 6 の成功基準は 唯一。**

> **意味のあるログが、安定して出ること**

それ以外（量・美しさ・完全性）はすべて Phase 7 以降に委ねる。

---

### 13.5 次フェーズへの引き渡し事項

Phase 7 に引き渡すもの：

- 確立された LogID 番号体系
- 状態遷移ログの設計思想
- 記録抑制ルール
- 型安全なCSV基盤
- 実運用で得られた知見

---

### 13.6 最終宣言

**Phase 6 は「ログを増やすフェーズ」ではない。**  
**「ログが信用できるか」を証明するフェーズである。**

**この仕様書は、Aegis が「ブラックボックス」になることを拒否するための最低限かつ十分な設計である。**

---

**Phase 6 状態ログ実装仕様書 v2.1 完**

---

